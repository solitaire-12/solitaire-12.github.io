{"meta":{"title":"织秋个人博客","subtitle":"副标题","description":"座右铭","author":"solitaire-12","url":"https://solitaire-12.github.io","root":"/"},"pages":[{"title":"","date":"2024-03-14T09:19:27.963Z","updated":"2024-03-14T09:19:27.963Z","comments":true,"path":"404.html","permalink":"https://solitaire-12.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2024-03-19T04:54:36.000Z","updated":"2024-03-19T07:03:10.484Z","comments":true,"path":"about/index.html","permalink":"https://solitaire-12.github.io/about/index.html","excerpt":"","text":"2024-03-19 切换主题 Volantis 2024-03-18 同步笔记 服务器环境配置笔记JVMJava8 2024-03-15 切换主题 Async 2024-03-14 博客建立 简单说一下为啥建立这个博客吧。原先用gitee存放自己的笔记，每次写完之后push一下就好了，也算方便。随着笔记越来越多，想要在这种方式下找到自己想要的内容，简直噩梦。也尝试过Notion，不过Notion会把鸡蛋放一个篮子里。思来想去，搞了这个博客。","author":"织秋"},{"title":"分类","date":"2024-03-14T07:40:18.000Z","updated":"2024-03-14T08:58:24.939Z","comments":true,"path":"categories/index.html","permalink":"https://solitaire-12.github.io/categories/index.html","excerpt":"","text":""},{"title":"frineds","date":"2024-03-19T04:55:03.000Z","updated":"2024-03-19T04:55:03.563Z","comments":true,"path":"frineds/index.html","permalink":"https://solitaire-12.github.io/frineds/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-03-14T08:59:06.000Z","updated":"2024-03-14T08:59:23.315Z","comments":true,"path":"tags/index.html","permalink":"https://solitaire-12.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-03-14T08:59:43.000Z","updated":"2024-03-14T09:00:13.560Z","comments":true,"path":"links/index.html","permalink":"https://solitaire-12.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"算法|数据结构(Java)","slug":"algorithm/数据结构","date":"2024-03-19T08:49:57.890Z","updated":"2024-03-19T09:27:49.212Z","comments":true,"path":"2024/03/19/algorithm/数据结构/","permalink":"https://solitaire-12.github.io/2024/03/19/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"线性表 数组和矩阵 优点 读取速度快 缺点 事先必须直到数组的长度 插入删除元素很慢，效率很低 空间通常是有限制的 需要大块连续的内存块 ArrayList源码解析 相关题目 链表 优点 空间没有限制 插入删除元素很快 缺点 存取速度很慢 分类 单向链表（每个节点，存在一个指向下一个节点的指针） 双向链表（每个节点，存在一个指针指向下一个节点，一个指针指向上一个节点） 循环链表（上述两种链表的基础上，拥有头尾互指指针） 12345678910111213141516public class Node &#123; //数据域 public int data; //指针域，指向下一个节点 public Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125;&#125; LinkedList源码解析 相关题目 哈希表 栈和队列 栈 - LIFO 数组实现的叫静态栈 链表实现的叫动态栈 队列 - FIFO 数组实现的叫静态队列 链表实现的叫动态队列 树 知识脉络 结构说明 ​ 树是一种数据结构，它是n(n&gt;=0)个节点的有限集。n=0时称为空树。n&gt;0时，有限集的元素构成一个具有层次感的数据结构。 ​ 区别在于线性表是一对一的关系，树中的节点是一对多的关系。树具有以下特点： n&gt;0时，根节点是唯一的，不可能存在多个根节点。 每个节点有零个或者多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点。 树的相关概念 子树：除了根节点外，每个子节点都可以由多个不相交的子树。 孩子与双亲：若一个节点有子树，那么该节点称为子树根的&quot;双亲&quot;，子树的根是该节点的&quot;孩子&quot;。在图一中，B、H是A的孩子，A是B、H的双亲。 兄弟：具有相同双亲的节点互为兄弟。例如B和H互为兄弟。 节点的度：一个节点拥有子树的数目。例如A的度就是2，B的度就是1，C的度就是3。 叶子：没有子树，也即度为0的节点。 分支节点：除了叶子节点之外的节点，也就是度不为0的节点。 内部节点：除了根节点之外的分支节点。 层次：根节点为第一层，其余节点的层次等于其双亲节点的层次加1。 树的高度：也称为树的深度，树中节点的最大层次。 有序树：树中节点各个子树之间的次序是重要的，不可以随意交换位置。 无序树：树中节点各个子树之间的次序是不重要的，可以随意交换位置。 森林：0或者多颗互不相交的树的集合。 二叉树 二叉树 最多有两颗子树的树 二叉树的五种状态 斜树 所有节点都只有左子树的二叉树叫做左斜树；所有节点都只有右子树的二叉树叫做右斜树。其本质是链表 满二叉树 二叉树中所有非叶子节点的的度都是2，且叶子节点都处于同一个层次上。 完全二叉树 如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树。 二叉查找树 - BST 二叉查找树(Binary Search Tree)是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于于它的根节点的值； 任意节点的左右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比较其他数据结构的优势在于查找、插入的时间复杂度较低，为O($log_{}n$)。 二叉查找树是基础性的数据结构，用于构建更为抽象的数据结构，如集合，多重集合，关联数组等。 二叉查找树的实现以及测试 平衡二叉树 - AVL 含有相同节点的二叉树可以有不同的形态，而二叉查找树的平均长度与树的深度有关，所以需要找出一个查到平均长度最小的一棵，那就是平衡二叉树，具有一下性质： 要么是棵空树，要么其根节点左右子树的深度之差绝对值不超过1； 其左右子树也都是平衡二叉树； 二叉树节点的平衡因子定义：（该节点的左子树的深度 - 右子树的深度）。则平衡二叉树的所有节点的平衡因子只可能是-1，0，1。 平衡二叉树的实现以及测试 红黑树 红黑树也是一种自平衡的二叉查找树，它的每个节点增加了一个存储位来记录节点的颜色，可以是RED，也可以是BLACK；通过任意一条从根到叶子检点路径上颜色的约束，红黑树保证最长路径不超过最短路径的两倍，因而近似平衡。 每个节点要么是红的要和是黑的。（红或黑） 根节点是黑的。（根黑） 每个叶节点（指树尾端NIL指针或NULL节点）都是黑的。（叶黑） 如果一个节点是红的，那么他的两个儿子都是黑的。（红子黑） 对于任意节点而言，其到叶节点树尾端NIL指针的每条路径都包含相同数目的黑节点。（路径下黑相同）。 应用： Java ConcurrentHashMap &amp; TreeMap C++ STL: map &amp; set linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块 epoll在内核中的实现，用红黑树管理事件块 nginx中，用红黑树管理timer等 AVL树和红黑树的比较： AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，CPU效率很高，所以性能差距也就变小了 红黑树的插入删除比AVL树更便于控制操作 红黑树整体性能略优于AVL树（红黑树旋转的情况少于AVL树） 红黑树的实现以及测试 哈夫曼树 哈夫曼树又称最优二叉树。是一种带权路径长度最短的二叉树，一般可以按下面的步骤构建： 将所有左右子树都为空的节点作为根节点。 在森林中选出两颗根节点的权值最小的树作为一棵新树的左右子树，且新树的附加节点的权值为其左右子树根节点的权值之和。注意，左子树的权值要小于右子树的权值。 从森林中删除这两棵树，同时把新的树加入到森林中。 重复2，3步骤，直到森林中只有一棵树为止，这棵树就是哈夫曼树。 B树 B树（B-Tree）是一种自平衡的树，能够保持数据的有序，这种数据结构能够让查找数据、顺序访问、插入数据以及删除的动作，都在对数时间内完成。B树，概括来说是一种自平衡的m阶树，与自平衡二叉树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。 根节点至少有两个子女； 每个中间节点都包含k-1个元素和k个孩子，其中$\\frac{m}{2}\\leq k \\leq m$； 每个叶子节点都包含k-1个元素，其中$\\frac{m}{2}\\leq k \\leq m$； 所有的叶子节点都位于同一层； 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree: B+树 通常用于关系型数据库（如MySQL）和操作系统的文件系统中。 特点是能够保持数据的稳定有序，其中插入与修改拥有稳定的对数时间复杂度。 元素自底向上插入，这与二叉树相反。 在B树的基础上，为叶子节点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子节点中出现，非叶子节点作为叶子节点的索引；B+树总是到叶子节点才命中。 B+树的非叶子节点不保存数据，只保存子树的临界值(最大或者最小)，所以同样大小的节点，B+树要比B树有更多的分支，使得这棵树更加矮胖，查询时做的I/O操作次数就会更少。 将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示: B+树的 R树 R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。 R树的核心思想是聚合距离相近的节点并在树结构的上一层将其表示为这些节点的最小外接矩形(MBR)，这个最小外接矩形就成为上一层的一个节点。因为所有节点都在它们的最小外接矩形中，所以跟某个矩形不相交的查询就一定跟这个矩形中的所有节点都不相交。叶子节点上的每个矩形都代表一个对象，节点都是对象的聚合，并且越往上层聚合的对象就越多。也可以把每一层看做是对数据集的近似，叶子节点层是最细粒度的近似，与数据集相似度100%，越往上层越粗糙。 总结 我们知道，实际应用当中，我们经常使用的是查找和排序操作，这在我们的各种管理系统、数据库系统、操作系统等当中，十分常用。 数组的下标寻址十分迅速，但计算机的内存是有限的，故数组的长度也是有限的，实际应用当中的数据往往十分庞大；而且无序数组的查找最坏情况需要遍历整个数组；后来人们提出了二分查找，二分查找要求数组的构造一定有序，二分法查找解决了普通数组查找复杂度过高的问题。任何一种数组无法解决的问题就是插入、删除操作比较复杂，因此，在一个增删查改比较频繁的数据结构中，数组不会被优先考虑 普通链表由于它的结构特点被证明根本不适合进行查找 哈希表是数组和链表的折中，同时它的设计依赖散列函数的设计，数组不能无限长、链表也不适合查找，所以也不适合大规模的查找 二叉查找树因为可能退化成链表，同样不适合进行查找 AVL树是为了解决可能退化成链表问题，但是AVL树的旋转过程非常麻烦，因此插入和删除很慢，也就是构建AVL树比较麻烦 红黑树是平衡二叉树和AVL树的折中，因此是比较合适的。集合类中的Map、关联数组具有较高的查询效率，它们的底层实现就是红黑树。 多路查找树 是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的(如果元素数量非常多的话，查找就退化成节点内部的线性查找了)，这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。 B树与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。它的应用是文件系统及部分非关系型数据库索引。 B+树在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。通常用于关系型数据库(如MySQL)和操作系统的文件系统中。 B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针, 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。 R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。 Trie树是自然语言处理中最常用的数据结构，很多字符串处理任务都会用到。Trie树本身是一种有限状态自动机，还有很多变体。什么模式匹配、正则表达式，都与这有关。 针对大量数据，如果在内存中作业优先考虑红黑树(map,set之类多为RB-tree实现)，如果在硬盘中作业优先考虑B系列树(B+, B, B*) 图 待续 Java集合源码解析 ArrayList 概述 ​ ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序是相同的，允许放入null元素，底层通过Object数组实现，未实现同步。 ​ 每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容量内存储元素的个数不能多于当前容量。在向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小（扩容机制）。 ​ size()，isEmpty()，get()，set()方法均能在常数时间内完成，add()方法的时间开销跟插入的位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都时线性时间。 ​ 追求效率，ArrayList也没有实现同步(synchronized)，如果需要多个线程访问的，用户需要手动同步（分析查看）。 源码解析 底层数据结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size;/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125;/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&#x27;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); if ((size = a.length) != 0) &#123; if (c.getClass() == ArrayList.class) &#123; elementData = a; &#125; else &#123; elementData = Arrays.copyOf(a, size, Object[].class); &#125; &#125; else &#123; // replace with empty array. elementData = EMPTY_ELEMENTDATA; &#125;&#125; 注意： 在无参构造方法中，可以看到ArrayList初始化了一个DEFAULTCAPACITY_EMPTY_ELEMENTDATA，这是一个容量为0的空Object数组。 在有参构造方法中，当传入的参数为零，或者集合大小为0的时候，初始化一个EMPTY_ELEMENTDATA，这是同样是一个容量为0的空Object数组。 综上两点，假若没有规定初始容量，ArrayList会初始化出一个容量为0的空Object数组。随后在往其中第一次添加元素的时候，进行扩容，默认容量(DEFAULT_CAPACITY)为10。 扩容机制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list&#x27;s current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125;/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It&#x27;s already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 描述： ​ 每当添加元素时，都会去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的要求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。所以，在添加大量元素前，可以通过这个方法来实现手动扩容，减少在添加元素过程中，自动扩容的次数，因为扩容的过程需要去复制源数组到新数组中，这个过程费时费空间。 ​ 数组进行扩容时，会将老数组中的元素拷贝一份到新的数组中，在grow方法中有这么一条代码：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);可以看出，数组每次扩容的时候，会扩容到当前容量的1.5倍。要是newCapacity超过了Integer.MAX_VALUE - 8($2^{31}-1-8$)就会把容量扩大到(Integer.MAX_VALUE)，这样就不会再扩容了。 add 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection&#x27;s Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection&#x27;s iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; ​ add(int index,E e)需要对元素进行移动，然后完成插入操作，也就意味着该方法的时间复杂度是线性的。 ​ addAll()方法能够一次添加多个元素，根据位置的不同，也有两个版本。一种是尾插法：addAll(Collection&lt;? extends E&gt; c)，一种是指定位置插入：addAll(int index, Collection&lt;? extends E&gt; c)。跟add()方法类似，在插入之前需要进行空间检查，判断是否需要扩容；如果从指定的位置插入，也会移动元素。综上：addAll()方法的时间复杂度和插入的元素个数以及插入位置有关。 set 1234567891011121314151617181920212223242526272829303132/** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;/** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;@SuppressWarnings(&quot;unchecked&quot;)E elementData(int index) &#123; return (E) elementData[index];&#125; get 123456789101112/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; remove 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 两个版本： 一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素 。 注意： ​ elementData[--size] = null; // clear to let GC do its work，这是为了让GC起作用。那为什么这里需要这种显示赋null值呢？ ​ 这是因为GC在判断对象能否回收是根据它是否在引用链上，而底层的数组维系着这个引用链。当删除一个元素之后，元素数量发生变化，所有后续元素往前移动，这样在引用链上就会多出来一个元素，按理这个元素应该是没有值的，要被GC掉。但是在后续元素往前移动的时候，是将后续元素拷贝一份，从删除位置开始从写原始位置上的值，这样的结果就导致了最后一个位置上是存在值的，GC确定不了这个对象是否该回收，故而在通过显示的赋null值，告诉GC可以回收该对象。 indexOf 123456789101112131415161718192021222324252627282930313233343536373839/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; Fail-Fast机制 ArrayList采用了快速失败机制，通过AbstractList抽象类中的modCount参数来实现。源码注解第二段提到：如果该字段的值发生意外变化，迭代器会快速失败，抛出ConcurrentModificationException异常，以响应next，remove，previous，set或add操作，以避免在迭代期间面对并发修改时的不确定性行为。 123456789101112131415161718192021222324252627/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its &#123;@code add(int, E)&#125; and * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */protected transient int modCount = 0; LinkedList 概述 LinkedList同时实现了List接口和Deque接口，它可以当作顺序容器，队列，栈。 LinkedList的实现方式决定了所有跟下表相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为了追求效率，LinkedList没有实现同步，如果需要保证线程安全，可从这里了解。 源码解析 底层数据结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546transient int size = 0;/** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */transient Node&lt;E&gt; first;/** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */transient Node&lt;E&gt; last;private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;/** * Constructs an empty list. */public LinkedList() &#123;&#125;/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&#x27;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; LinkedList底层是双向链表，每个节点用内部类Node表示。通过first和last引用分别指向链表的第一个和最后一个元素。当链表为空时，first和last都指向null。 getFirst，getLast 获取第一个元素和获取最后一个元素： 12345678910111213141516171819202122232425/** * Returns the first element in this list. * * @return the first element in this list * @throws NoSuchElementException if this list is empty */public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;/** * Returns the last element in this list. * * @return the last element in this list * @throws NoSuchElementException if this list is empty */public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; remove 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;/** * Unlinks non-null first node f. */private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125;/** * Removes and returns the last element from this list. * * @return the last element from this list * @throws NoSuchElementException if this list is empty */public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;/** * Unlinks non-null last node l. */private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125;/** * Removes the first occurrence of the specified element from this list, * if it is present. If this list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &#123;@code i&#125; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &#123;@code true&#125; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &#123;@code true&#125; if this list contained the specified element */public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;/** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;/** * Unlinks non-null node x. */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; remove有两个版本，一个用来删除指定下表的元素remove(int index)，一个用来删除与指定元素相等的第一个元素remove(Object o) 删除元素：指删除第一次出现的元素，如果没有这个元素，则返回false；判断的依据是equals方法，如果equals，则直接unlink这个node；由于LinkedList可以存放null元素，故而也可以删除第一次出现的null元素。 add 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;/** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any * subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;/** * Inserts element e before non-null Node succ. */void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125;private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; add(E e)尾插法 add(int index,E e)在指定下标位置插入元素。当index == size时，等同于add(E e)；如果不是，则分成两步：1. 根据index找到要插入的位置，即node(index)方法；2. 修改引用，完成插入操作。 123456789101112131415161718/** * Returns the (non-null) Node at the specified element index. */Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; node(int index)方法中，通过index &lt; (size &gt;&gt; 1)来提高节点查询的效率，时间复杂度是O($\\frac{n}{2}$)。 addAll addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the specified * collection&#x27;s iterator. The behavior of this operation is undefined if * the specified collection is modified while the operation is in * progress. (Note that this will occur if the specified collection is * this list, and it&#x27;s nonempty.) * * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection&#x27;s iterator. * * @param index index at which to insert the first element * from the specified collection * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; clear 为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。 1234567891011121314151617181920/** * Removes all of the elements from this list. * The list will be empty after this call returns. */public void clear() &#123; // Clearing all of the links between nodes is &quot;unnecessary&quot;, but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++;&#125; get，set 123456789101112131415161718192021222324252627/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;/** * Replaces the element at the specified position in this list with the * specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; 查找 找到返回下标，在、没找到返回-1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &#123;@code i&#125; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. * * @param o element to search for * @return the index of the first occurrence of the specified element in * this list, or -1 if this list does not contain the element */public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125;/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &#123;@code i&#125; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. * * @param o element to search for * @return the index of the last occurrence of the specified element in * this list, or -1 if this list does not contain the element */public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1;&#125; Coding code：数组和矩阵 283. Move Zeroes (Easy) 目标：给定一个数组，将数组中的0，移动到数组的右边。例如[0,1,2,0,3],改成[1,2,3,0,0] 1234567891011121314public static void moveZeroes(int[] nums) &#123; // 记录当前非零数的位置 int idx = 0; for (int num : nums) &#123; if (num != 0) &#123; // 元素不为0，将该元素放到非零位置上 nums[idx++] = num; &#125; &#125; // 将剩余的元素全部赋值为0 while (idx &lt; nums.length) &#123; nums[idx++] = 0; &#125;&#125; 566. Reshape the Matrix (Easy) 目的：改变矩阵的维度， 123456789101112131415public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int m = nums.length, n = nums[0].length; if (m * n != r * c) &#123; return nums; &#125; int[][] reshapedNums = new int[r][c]; int index = 0; for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; reshapedNums[i][j] = nums[index / n][index % n]; index++; &#125; &#125; return reshapedNums;&#125; 485. Max Consecutive Ones (Easy) 目的：找到数组中最长连续的1的长度 12345678public int findMaxConsecutiveOnes(int[] nums) &#123; int max = 0, cur = 0; for (int x : nums) &#123; cur = x == 0 ? 0 : cur + 1; max = Math.max(max, cur); &#125; return max;&#125; code：链表 参考 ♥数据结构基础知识体系详解♥ | Java 全栈知识体系 (pdai.tech) java实现AVL树_java实现2-3树-CSDN博客 红黑树(五)之 Java的实现 - 如果天空不死 - 博客园 (cnblogs.com)","categories":[{"name":"算法","slug":"算法","permalink":"https://solitaire-12.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://solitaire-12.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"织秋"},{"title":"Java|集合特性测试","slug":"Java/集合","date":"2024-03-19T08:40:55.000Z","updated":"2024-03-19T08:47:27.895Z","comments":true,"path":"2024/03/19/Java/集合/","permalink":"https://solitaire-12.github.io/2024/03/19/Java/%E9%9B%86%E5%90%88/","excerpt":"","text":"小结 Collection 接口的接口 对象的集合（单列集合） List 接口：元素按进入先后有序保存，可重复 LinkedList：链表， 插入删除， 没有同步， 线程不安全 ArrayList：数组， 随机访问， 没有同步， 线程不安全 Vector ：数组， 同步， 线程安全 Stack：是Vector类的实现类 Set 接口： 仅接收一次，不可重复，并做内部排序 HashSet：使用hash表（数组）存储元素 LinkedHashSet：链表维护元素的插入次序 TreeSet：底层实现为二叉树，元素排好序 Map 接口：键值对的集合 （双列集合） Hashtable：同步， 线程安全 HashMap：没有同步， 线程不安全 LinkedHashMap：双向链表和哈希表实现 WeakHashMap TreeMap：红黑树对所有的key进行排序 IdentifyHashMap 123456789101112131415161718192021222324252627282930private static &lt;T extends AbstractCollection&gt; void setInfo(T s) &#123;setInfo(s,null);&#125;private static &lt;T extends AbstractCollection&gt; void setInfo(T s, String info) &#123; String typeName = s.getClass().getTypeName().split(&quot;\\\\.&quot;)[2]; System.out.println(&quot;+======&quot; + typeName + &quot;=======================&quot;); System.out.print(&quot;| &quot; + typeName + &quot;源数据：&quot;); for (int i = 0; i &lt; 10; i++) &#123; Random random = new Random(); int i1 = random.nextInt(10); if (info != null &amp;&amp; !info.isEmpty()) &#123; System.out.print(info + i1 + &quot;,&quot;); s.add(info + i1); &#125; else &#123; System.out.print(i1 + &quot;,&quot;); s.add(i1); &#125; try &#123; if (i == 7)&#123; s.add(null); &#125; &#125;catch (Exception e)&#123; System.out.print(&quot;[尝试写入null数据,出现异常：e = &quot; + e.getClass().getTypeName().split(&quot;\\\\.&quot;)[2]+&quot;],&quot;); &#125; &#125; System.out.println(); System.out.print(&quot;| &quot; + typeName + &quot;处理后：&quot;); s.forEach(a -&gt; System.out.print(a + &quot;,&quot;)); System.out.println(); System.out.println(&quot;+========================================&quot;);&#125; List 校验array和linked的区别 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static &lt;T extends AbstractList&gt; T setList(T t, int num) &#123; for (int i = 0; i &lt; num; i++) &#123; Random random = new Random(); int i1 = random.nextInt(10); t.add(i1); &#125; return t;&#125;private static &lt;T extends AbstractList&gt; T addOne(T t, int e) &#123; t.add(50000,e); return t;&#125;private static &lt;T extends AbstractList&gt; T removeOne(T t, int index) &#123; t.remove(index); return t;&#125;private static &lt;T extends AbstractList&gt; void getOne(T t, int index)&#123; t.get(index);&#125;private static &lt;T extends AbstractList&gt; T consume(T t, String a, int num) &#123; String typeName = t.getClass().getTypeName().split(&quot;\\\\.&quot;)[2]; if (a != null &amp;&amp; a.equals(&quot;a&quot;)) &#123; long startTime = System.currentTimeMillis(); addOne(t, num); System.out.println(typeName + &quot;:addOne:总计耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); &#125; if (a != null &amp;&amp; a.equals(&quot;r&quot;)) &#123; long startTime = System.currentTimeMillis(); removeOne(t, num); System.out.println(typeName + &quot;:removeOne:总计耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); &#125; if (a != null &amp;&amp; a.equals(&quot;g&quot;)) &#123; long startTime = System.currentTimeMillis(); getOne(t, num); System.out.println(typeName + &quot;:getOne:总计耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); &#125; if (a == null) &#123; long startTime = System.currentTimeMillis(); setList(t, num); System.out.println(typeName + &quot;:setList:总计耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); &#125; return t;&#125; 123456789101112public void testList() &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = consume(arrayList, null, 10_000_000); consume(list, &quot;a&quot;, 5); consume(list, &quot;r&quot;, 5_000); consume(list, &quot;g&quot;, 1000_000); LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; list1 = consume(linkedList, null, 10_000_000); consume(list1, &quot;a&quot;, 5); consume(list1, &quot;r&quot;, 5_000); consume(list1, &quot;g&quot;, 1000_000);&#125; 12345678ArrayList:setList:总计耗时：629msArrayList:addOne:总计耗时：4msArrayList:removeOne:总计耗时：4msArrayList:getOne:总计耗时：0msLinkedList:setList:总计耗时：1901msLinkedList:addOne:总计耗时：1msLinkedList:removeOne:总计耗时：0msLinkedList:getOne:总计耗时：3ms 校验null值 123456public void testList1() &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); setInfo(arrayList); LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); setInfo(linkedList);&#125; 12345678+======ArrayList=======================| ArrayList源数据：4,5,1,1,8,9,8,2,2,8,| ArrayList处理后：4,5,1,1,8,9,8,2,null,2,8,+========================================+======LinkedList=======================| LinkedList源数据：7,6,4,8,0,3,5,9,4,2,| LinkedList处理后：7,6,4,8,0,3,5,9,null,4,2,+======================================== 校验线程安全问题 123456789101112131415161718192021222324252627282930313233public void testSafe() &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); inThread(arrayList, 3, 1000); LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); inThread(linkedList, 3, 1000);&#125;private static &lt;T extends AbstractList&gt; void inThread(T t, int tNum, int eNum) &#123; Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; tNum; i++) &#123; Thread thread1 = new Thread(() -&gt; setList(t, eNum)); thread1.start(); &#125; &#125;); thread.start(); try &#123; thread.join(); Thread.sleep(eNum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //System.out.println( // MessageFormat.format(&quot;在&#123;0&#125;个线程,每线程添加&#123;1&#125;个元素的情况下,&#123;2&#125;中元素数量是:&#123;3&#125;&quot;, // tNum,eNum,t.getClass().getTypeName().split(&quot;\\\\.&quot;)[2],t.size())); System.out.println( String.format(&quot;在%1$s个线程,每线程添加%2$s个元素的情况下,%3$s中元素数量是:%4$s&quot;, tNum,eNum,t.getClass().getTypeName().split(&quot;\\\\.&quot;)[2],t.size()));&#125;// 在3个线程,每线程添加1000个元素的情况下,ArrayList中元素数量是:1242// 在3个线程,每线程添加1000个元素的情况下,LinkedList中元素数量是:2887 list总结 数据可重复,可为null ArrayList和LinkedList区别 两者都不保证线程安全 ArrayList查询快,增删慢LinkedList查询慢,增删快 上述代码中：为什么两者同样是插入10_000_000条数据,LinkedList要比ArrayList慢这么多？ 这是因为setList方法中用来添加元素的方式是尾插法， 参考可以了解到，在大数据量的情况下，ArrayList的扩容机制同LinkedList的Node机制要更有优势。 为什么线程不安全呢？ ArrayList不安全的原因： 首先明确ArrayList添加元素的操作是在add元素时，通过size下标进行写入集合，这一过程中用到了size++操作，这是无法保证原子性的操作，也就导致ArrayList在多线程环境下，可能会触发数组下标越界的错误ArrayIndexOutOfBoundsException，或者size同时被多个线程读取的问题。 LinkdedList不安全的原因： 首先明确LinkedList API中添加元素方法有多种，这里就用linkLast方法为例。该方法涉及变量尾指针``Node last，下一个指针 Node newNode，大小size,以及修改次数modCount。方法内size++和modCount++这两个操作无法保证原子性，导致在多线程环境下，存在多个同时获取相同的size和modCount`数值的线程，从而导致尾指针出现异常情况。 如何保证线程安全呢？ 12Collection&lt;Integer&gt; synchronizedCollection = Collections.synchronizedCollection(new ArrayList&lt;Integer&gt;()); 1CopyOnWriteArrayList&lt;Integer&gt; copyOnWriteArrayList = new CopyOnWriteArrayList&lt;&gt;(); 方式1：属于java.util.Collections，通过synchronized实现线程安全。直接锁集合对象，性能不太行。 12345SynchronizedCollection(Collection&lt;E&gt; c) &#123; this.c = Objects.requireNonNull(c); mutex = this;&#125;public boolean add(E e) &#123;synchronized (mutex) &#123;return c.add(e);&#125;&#125; 方式2：属于java.util.concurrent.CopyOnWriteArrayList，诸如add，remove，set中存在着copyOf操作，导致该api在处理大数据量的时候，性能表现极差。下面是源码： 1234567891011121314151617181920public boolean add(E e) &#123; final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try &#123; // 获取当前元素集 Object[] elements = getArray(); // 获取长度 int len = elements.length; // 拷贝一份容量比原先大1 Object[] newElements = Arrays.copyOf(elements, len + 1); // 将元素加入到新元素集合 newElements[len] = e; // 将新元素集合写到list中 setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 两者都没有继承AbstractList Set 校验特性 1234567891011121314TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();setInfo(treeSet,null);HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();setInfo(hashSet, null);LinkedHashSet&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();setInfo(linkedHashSet,null);System.out.println(&quot;TreeSet和HashSet的区别&quot;);TreeSet&lt;Integer&gt; treeSet2 = new TreeSet&lt;&gt;();setInfo(treeSet2, &quot;号&quot;);HashSet&lt;Integer&gt; hashSet2 = new HashSet&lt;&gt;();setInfo(hashSet2, &quot;号&quot;); 123456789101112131415161718192021+======TreeSet=======================| TreeSet源数据：6,0,8,6,6,9,6,2,[尝试写入null数据,出现异常：e = NullPointerException],1,3,| TreeSet处理后：0,1,2,3,6,8,9,+========================================+======HashSet=======================| HashSet源数据：4,0,2,5,5,7,1,7,5,5,| HashSet处理后：0,null,1,2,4,5,7,+========================================+======LinkedHashSet=======================| LinkedHashSet源数据：4,4,1,7,5,3,1,1,0,3,| LinkedHashSet处理后：4,1,7,5,3,null,0,+========================================TreeSet和HashSet的区别+======TreeSet=======================| TreeSet源数据：号1,号5,号5,号4,号4,号5,号6,号0,[尝试写入null数据,出现异常：e = NullPointerException],号7,号0,| TreeSet处理后：号0,号1,号4,号5,号6,号7,+========================================+======HashSet=======================| HashSet源数据：号8,号6,号9,号2,号1,号5,号0,号6,号8,号8,| HashSet处理后：号1,null,号2,号0,号5,号6,号9,号8,+======================================== 校验线程安全 123456789101112131415161718private static &lt;T extends AbstractSet&gt; void inThread(T t, int tNum, int eNum) &#123; Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; tNum; i++) &#123; Thread thread1 = new Thread(() -&gt; setSet(t, eNum)); thread1.start(); &#125; &#125;); thread.start(); try &#123; thread.join(); Thread.sleep(eNum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println( String.format(&quot;在%1$s个线程,每线程添加%2$s个元素的情况下,%3$s中元素数量是:%4$s&quot;, tNum, eNum, t.getClass().getTypeName().split(&quot;\\\\.&quot;)[2], t.size()));&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public void testSetSafe() &#123; // Testing whether a TreeSet is thread-safe TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;(); inThread(treeSet, 3, 1000); // Implementing thread-safe TreeSet Collection&lt;Integer&gt; synchronizedTreeSet = Collections.synchronizedCollection(new TreeSet&lt;Integer&gt;()); Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread thread1 = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; synchronizedTreeSet.add(j); &#125; &#125;); thread1.start(); &#125; &#125;); thread.start(); try &#123; thread.join(); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;synchronizedTreeSet:&quot; + synchronizedTreeSet.size()); // Testing whether a HashSet is thread-safe HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(); inThread(hashSet,3,1000); // Implementing thread-safe HashSet Collection&lt;Integer&gt; synchronizedHashSet = Collections.synchronizedCollection(new HashSet&lt;&gt;()); Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread thread1 = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; synchronizedHashSet.add(j); &#125; &#125;); thread1.start(); &#125; &#125;); thread.start(); try &#123; thread.join(); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;synchronizedHashSet:&quot; + synchronizedHashSet.size()); // Testing whether a LinkedHashSet is thread-safe LinkedHashSet&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;(); inThread(linkedHashSet,3,1000); // Implementing thread-safe LinkedHashSet Collection&lt;Integer&gt; synchronizedLinkedHashSet = Collections.synchronizedCollection(new LinkedHashSet&lt;&gt;()); Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread thread1 = new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; synchronizedLinkedHashSet.add(j); &#125; &#125;); thread1.start(); &#125; &#125;); thread.start(); try &#123; thread.join(); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;synchronizedLinkedHashSet:&quot; + synchronizedLinkedHashSet.size());&#125; 结果 123456789java.lang.NullPointerException在3个线程,每线程添加1000个元素的情况下,TreeSet中元素数量是:1005synchronizedTreeSet::1000在3个线程,每线程添加1000个元素的情况下,HashSet中元素数量是:1110synchronizedHashSet:1000在3个线程,每线程添加1000个元素的情况下,LinkedHashSet中元素数量是:1055synchronizedLinkedHashSet:1000 set总结 保证数据是唯一的 TreeSet，HashSet，LinkedHashSet三者的区别 TreeSet不能存储null数据HashSet和LinkedHashSet可以存储null数据 TreeSet可以保证数据有序HashSet可以保证重写hashcode的数据类型有序LinkedHashSet可以保留插入顺序 TreeSet底层是二叉树HashSet底层是hashLinkedHashSet底层是链表hash TreeSet调了一个NavigableMap，其插入操作会去调用TreeMap中的put方法。多线程中，在调用put时，可能遇到多个线程在添加同一个元素的情况出现，这使compare的结果一致，从而触发插入多个同一元素的情况。 1234567891011private transient NavigableMap&lt;E,Object&gt; m; private static final Object PRESENT = new Object(); TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m;&#125; public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;());&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); @SuppressWarnings(&quot;unchecked&quot;) Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;&#125; HashSet内部调了个HashMap，其插入操作会去调用HashMap中的put方法。多线程中，在调用put时，可能遇到多个线程在添加同一个元素的情况出现，这使对比hash的结果一致，从而触发插入多个同一元素的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; LinkedHashSet是链表结构的HashSet，调的都是HashMap。 Map 校验特性 Hashtable 123456789101112131415161718Hashtable&lt;Integer, Integer&gt; hashtable = new Hashtable&lt;&gt;();try &#123; hashtable.put(1,1); hashtable.put(1,2); hashtable.put(3,3); hashtable.put(4,null); hashtable.put(null,2);&#125;catch (Exception e)&#123; System.out.println(&quot;e = &quot; + e);&#125;hashtable.keySet().forEach((key)-&gt;&#123; System.out.print(&quot;key = &quot; + key); System.out.println(&quot;,value = &quot;+ hashtable.get(key));&#125;);// e = java.lang.NullPointerException// key = 3,value = 3// key = 1,value = 2 结果： key和value都不能为空 同key覆盖 不建议使用HashTable，Oracle官方也将其废弃，建议在多线程环境下使用ConcurrentHashMap类。 线程安全 1234567891011121314151617181920212223242526272829Hashtable&lt;Integer, Integer&gt; hashtable = new Hashtable&lt;&gt;();inThread(hashtable,3,1000);private static &lt;T extends Dictionary&gt; void inThread(T t, int tNum, int eNum) &#123; Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; tNum; i++) &#123; Thread thread1 = new Thread(() -&gt; setMap(t, eNum)); thread1.start(); &#125; &#125;); thread.start(); try &#123; thread.join(); Thread.sleep(eNum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println( String.format(&quot;在%1$s个线程,每线程添加%2$s个元素的情况下,%3$s中元素数量是:%4$s&quot;, tNum, eNum, t.getClass().getTypeName().split(&quot;\\\\.&quot;)[2], t.size()));&#125;private static &lt;T extends Dictionary&gt; T setMap(T t, int num) &#123; for (int i = 0; i &lt; num; i++) &#123; t.put(i, i); &#125; return t;&#125;// 在3个线程,每线程添加1000个元素的情况下,Hashtable中元素数量是:1000 HashMap 12345678910111213141516171819202122HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();try&#123; hashMap.put(1,1); hashMap.put(1,2); hashMap.put(3,3); hashMap.put(4,null); hashMap.put(null,2);&#125;catch (Exception e)&#123; System.out.println(&quot;e = &quot; + e);&#125;hashMap.keySet().forEach((key)-&gt;&#123; System.out.print(&quot;key = &quot; + key); System.out.println(&quot;,value = &quot;+ hashMap.get(key));&#125;);//key = null,value = 2//key = 1,value = 2//key = 3,value = 3//key = 4,value = nullHashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();inThread(hashMap,3,1000);//在3个线程,每线程添加1000个元素的情况下,HashMap中元素数量是:1020 结果： 允许key和value为null 线程不安全 LinkedMap 1234567891011121314151617181920212223LinkedHashMap&lt;Integer, Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();try&#123; linkedHashMap.put(1,1); linkedHashMap.put(1,2); linkedHashMap.put(3,3); linkedHashMap.put(4,null); linkedHashMap.put(null,2);&#125;catch (Exception e)&#123; System.out.println(&quot;e = &quot; + e);&#125;linkedHashMap.keySet().forEach(key-&gt;&#123; System.out.print(&quot;key = &quot; + key); System.out.println(&quot;,value = &quot;+ linkedHashMap.get(key));&#125;);//key = 1,value = 2//key = 3,value = 3//key = 4,value = null//key = null,value = 2LinkedHashMap&lt;Integer, Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();inThread(linkedHashMap,3,1000);// 在3个线程,每线程添加1000个元素的情况下,LinkedHashMap中元素数量是:1157 结果： 源码，其继承自HashMap 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; 线程不安全 TreeMap 1234567891011121314151617181920212223TreeMap&lt;Integer, Integer&gt; treeMap = new TreeMap&lt;&gt;();try &#123; treeMap.put(1, 1); treeMap.put(1, 2); treeMap.put(3, 3); treeMap.put(4, null); treeMap.put(null, 2);&#125; catch (Exception e) &#123; System.out.println(&quot;e = &quot; + e);&#125;treeMap.keySet().forEach((key) -&gt; &#123; System.out.print(&quot;key = &quot; + key); System.out.println(&quot;,value = &quot; + treeMap.get(key));&#125;);//e = java.lang.NullPointerException//key = 1,value = 2//key = 3,value = 3//key = 4,value = nullTreeMap&lt;Integer, Integer&gt; treeMap = new TreeMap&lt;&gt;();inThread(treeMap,3,1000);// NullPointerException// 在3个线程,每线程添加1000个元素的情况下,TreeMap中元素数量是:1016 结果： 不允许key为null，value可以为null 同key覆盖 线程不安全 ConcurrentHashMap 12345678910111213141516171819202122ConcurrentHashMap&lt;Integer, Integer&gt; concurrentHashMap = new ConcurrentHashMap&lt;&gt;();try &#123; concurrentHashMap.put(1, 1); concurrentHashMap.put(1, 2); concurrentHashMap.put(3, 3); concurrentHashMap.put(4, null); concurrentHashMap.put(null, 2);&#125; catch (Exception e) &#123; System.out.println(&quot;e = &quot; + e);&#125;concurrentHashMap.keySet().forEach((key) -&gt; &#123; System.out.print(&quot;key = &quot; + key); System.out.println(&quot;,value = &quot; + concurrentHashMap.get(key));&#125;);// e = java.lang.NullPointerException// key = 1,value = 2// key = 3,value = 3ConcurrentHashMap&lt;Integer, Integer&gt; concurrentHashMap = new ConcurrentHashMap&lt;&gt;();inThread(concurrentHashMap,3,1000);//在3个线程,每线程添加1000个元素的情况下,concurrent中元素数量是:1000 结果： 属于java.util.concurrent，但继承了AbstractMap 不允许key，value为null 线程安全 检验线程安全代码 123456789101112131415161718192021222324private static &lt;T extends AbstractMap&gt; void inThread(T t, int tNum, int eNum) &#123; Thread thread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; tNum; i++) &#123; Thread thread1 = new Thread(() -&gt; setMap(t, eNum)); thread1.start(); &#125; &#125;); thread.start(); try &#123; thread.join(); Thread.sleep(eNum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println( String.format(&quot;在%1$s个线程,每线程添加%2$s个元素的情况下,%3$s中元素数量是:%4$s&quot;, tNum, eNum, t.getClass().getTypeName().split(&quot;\\\\.&quot;)[2], t.size()));&#125;private static &lt;T extends AbstractMap&gt; T setMap(T t, int num) &#123; for (int i = 0; i &lt; num; i++) &#123; t.put(i, i); &#125; return t;&#125; java.util.concurrent 集合类在java.util，为解决并发问题，提供了java.util.concurrent解决方案。比如常用的HashMap并发解决方案的ConcurrentHashMap就在这个包下。更多内容多线程-concurrent中介绍。 Collections 对collection操作的工具类。 摘要几个常用的API 方法 描述 sort(List&lt;T&gt; list [, Comparator&lt;? super T&gt; c]) 对list进行排序；重载一个比较器版本 synchronizedCollection(Collection&lt;T&gt; c) synchronizedList(List&lt;T&gt; list)synchronizedMap(Map&lt;K,V&gt; map)synchronizedSet(Set&lt;T&gt; set) 提供并发解决方案 min/max (Collection&lt;T&gt; c [, Comparator&lt;? super T&gt; c]) 获取最小/最大值 reverse(List&lt;T&gt; list) 反转列表 replaceAll(List&lt;T&gt; list,T oldVal,T newVal) 替换列表中元素 swap(List&lt;T&gt; list,int i,int j) 列表中元素交换位置 copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) src往dest拷贝，确保src.size比dest.size小","categories":[{"name":"Java","slug":"Java","permalink":"https://solitaire-12.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://solitaire-12.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java|泛型","slug":"Java/泛型","date":"2024-03-19T08:10:55.000Z","updated":"2024-03-19T08:35:33.657Z","comments":true,"path":"2024/03/19/Java/泛型/","permalink":"https://solitaire-12.github.io/2024/03/19/Java/%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"为啥引入泛型 进入话题前，先看一段代码： 123456private static Integer add(Integer a,Integer b)&#123; return a+b;&#125;private static Double add(Double a,Double b)&#123; return a+b;&#125; 通常情况下，我们给一个方法设定形参时，会直接写上形参的类型。但是，当我们的方法传参不确定类型时，例如方法add的形参是Integer,Integer或者是Double,Double,这时要是传来Integer,Double，你可能会去写重载该方法，使其达到一个方法实现接受几种参数类型这就很折磨人了。为了解决这种麻烦，引入泛型。 引用泛型 123private static &lt;T extends Number&gt; double addt(T a,T b)&#123; return a.doubleValue()+b.doubleValue();&#125; 这样，无论调用这传递什么样的数字类型，都可以调用该方法，不用再去重载方法了。 在集合中，List&lt;String&gt;代表着List只能存放String类型，用来表示约束。 泛型的使用 泛型类 单一泛型类： 123456789101112131415161718192021222324class Hello&lt;T&gt;&#123; private T word; public T getWord() &#123; return word; &#125; public void setWord(T word) &#123; this.word = word; &#125;&#125;public class test &#123; public static void main(String[] args) &#123; Hello&lt;String&gt; hello = new Hello&lt;String&gt;(); hello.setWord(&quot;你好，泛型&quot;); // 你好，泛型 System.out.println(hello.getWord()); Hello&lt;Integer&gt; hello1 = new Hello&lt;Integer&gt;(); hello1.setWord(12323); // 12323 System.out.println(hello1.getWord()); &#125;&#125; 多元泛型类： 123456789101112131415161718192021222324252627282930class Notepad&lt;K,V&gt;&#123; private K key; private V value; public K getKey() &#123; return key; &#125; public void setKey(K key) &#123; this.key = key; &#125; public V getValue() &#123; return value; &#125; public void setValue(V value) &#123; this.value = value; &#125;&#125;public class test &#123; public static void main(String[] args) &#123; Notepad&lt;String, Integer&gt; notepad = new Notepad&lt;&gt;(); notepad.setKey(&quot;tom&quot;); notepad.setValue(20); System.out.println(notepad.getKey()); System.out.println(notepad.getValue()); &#125;&#125; 泛型接口 1234567891011121314151617181920212223242526interface Hello&lt;T&gt;&#123; public T getWord();&#125;class HelloImpl&lt;T&gt; implements Hello&lt;T&gt;&#123; private T word; public HelloImpl(T word) &#123; this.word = word; &#125; public void setWord(T word) &#123; this.word = word; &#125; @Override public T getWord() &#123; return this.word; &#125;&#125;public class test &#123; public static void main(String[] args) &#123; HelloImpl&lt;String&gt; hello = new HelloImpl&lt;String&gt;(&quot;你好,接口泛型&quot;); System.out.println(hello.getWord()); &#125;&#125; 泛型方法 123public &lt;T&gt; T get(T a) &#123; return a;&#125; &lt;T&gt;:声明一个泛型T T:声明方法的返回类型是泛型T get(T a):方法的形参是一个泛型T的变量 上述中，1是必须申明的，2，3可以视情况使用其中之一或者两者一起使用。假如两者都使用，虽然没有问题，但是方法却没有涉及&lt;T&gt;，属于无效代码。 参考：泛型机制详解](https://pdai.tech/md/java/basic/java-basic-x-generic.html)","categories":[{"name":"Java","slug":"Java","permalink":"https://solitaire-12.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://solitaire-12.github.io/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"算法|排序","slug":"algorithm/sort","date":"2024-03-19T07:33:11.324Z","updated":"2024-03-19T08:13:17.393Z","comments":true,"path":"2024/03/19/algorithm/sort/","permalink":"https://solitaire-12.github.io/2024/03/19/algorithm/sort/","excerpt":"","text":"认识位运算符 获取整数的二进制32位字符 123456public static void print(int num) &#123; for (byte i = 31; i &gt;= 0; i--) &#123; System.out.print((num &amp; (1 &lt;&lt; i)) == 0 ? &quot;0&quot; : &quot;1&quot;); &#125; System.out.println();&#125; 结果： 123456789101112131415byte a = 43;byte b = 120;System.out.print(&quot;a :&quot;);print(a); //a :00101011System.out.print(&quot;b :&quot;);print(b); //b :01111000System.out.print(&quot;a|b:&quot;);print(a | b); //a|b:01111011System.out.print(&quot;a&amp;b:&quot;);print(a &amp; b); //a&amp;b:00101000System.out.print(&quot;a^b:&quot;);print(a ^ b); //a^b:01010011System.out.print(&quot; ~b:&quot;);print(~b); // ~b:10000111System.out.print(&quot;135:&quot;);print(135); //135:10000111System.out.print(&quot;a :&quot;);print(a); //a :00101011System.out.print(&quot;&lt;&lt;3:&quot;);print(a&lt;&lt;3); //&lt;&lt;3:01011000System.out.print(&quot;&gt;&gt;1:&quot;);print(a&gt;&gt;1); //&gt;&gt;1:00010101System.out.print(&quot;&gt;&gt;&gt;1:&quot;);print(a&gt;&gt;&gt;1); //&gt;&gt;&gt;1:00010101System.out.println(~b); //-121print(~b&gt;&gt;7); //11111111 |：或 1234//00101011//01111000//01111011print(43 | 120); //01111011 有1为1 &amp;：与 1234//00101011//01111000//00101000print(43 &amp; 120); //00101000 有0为0 ^：亦或 1234//00101011//01111000//01010011print(43 ^ 120); //01010011 无进位相加 ~：非 取反 1234//01111000//10000111print(~120); //10000111print(135); //10000111 ~120和135的字符是一样的，为什么它是-121不是135呢？ 首先理解，byte 占 8位（-128-127），其中[符号位]占一位，其余数据占用 其次当一个数是负数的时候，符号位以及其左边的位置，均为1。也就是说，-121是//1111....110000111，而135是//0000.....010000111 最后，~操作可以理解成在一条直线上，从[0和-1的中间位置]反方向去找到第n个点 注意：在程序中，0算正数。后文会验证这一结论。 &lt;&lt;：左移 12print(43); //00101011print(43&lt;&lt;3); //01011000 &gt;&gt;：右移 12print(43); //00101011print(43&gt;&gt;1); //00010101 &gt;&gt;&gt;：无符号右移 123print(43&gt;&gt;&gt;1); //00010101print(~120); //10000111print(~120&gt;&gt;7); //11111111 正数&gt;&gt;&gt; 等价 &gt;&gt; 常见使用 判断奇偶性 1(num &amp; 1) == 1 ? &quot;奇数&quot; : &quot;偶数&quot; 两个数做交换 123456789a = a ^ b;b = a ^ b;a = a ^ b;// 注意：在数组操作中时，切记不能进行用位置亦或，不然数据会丢失//可以简化成a ^= b;b ^= a;a ^= b; 取绝对值 12int b = -327int a = (b ^ (b&gt;&gt;31)) - (b&gt;&gt;31); 判断两个数是否异号 123456boolean f = ((x ^ y) &lt; 0);// 同号false，异号true// boolean f = ((0 ^ 1) &lt; 0);// System.out.println(f);// 结果是false 大小写转换 123456// (&#x27;A&#x27; | &#x27; &#x27;) = &#x27;a&#x27;// (&#x27;a&#x27; | &#x27; &#x27;) = &#x27;a&#x27;// (&#x27;A&#x27; &amp; &#x27;_&#x27;) = &#x27;A&#x27;// (&#x27;a&#x27; &amp; &#x27;_&#x27;) = &#x27;A&#x27;// (&#x27;A&#x27; ^ &#x27; &#x27;) = &#x27;a&#x27;// (&#x27;a&#x27; ^ &#x27; &#x27;) = &#x27;A&#x27; +1 12int n = 10;n = -~n; -1 12int n = 10;n = ~-n; 排序 排序动态展示（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序） - VisuAlgo 打印 1Arrays.stream(arr).forEach(a-&gt; System.out.print(a + &quot; &quot;)); 交换 12345public static void swap(int[] arr, int i, int j) &#123; int tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;&#125; 选择排序 12345678910111213public static void selectSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int N = arr.length; for (int i = 0; i &lt; N; i++) &#123; int minValueIndex = i; for (int j = i + 1; j &lt; N; j++) &#123; minValueIndex = arr[j] &lt; arr[minValueIndex] ? j : minValueIndex; &#125; swap(arr, i, minValueIndex); &#125;&#125; 冒泡排序 12345678910111213public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int N = arr.length; for (int end = N - 1; end &gt;= 0; end--) &#123; for (int second = 1; second &lt;= end; second++) &#123; if (arr[second - 1] &gt; arr[second]) &#123; swap(arr, second - 1, second); &#125; &#125; &#125;&#125; 插入排序 12345678910111213141516171819202122232425public static void insertSort1(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int N = arr.length; for (int end = 1; end &lt; N; end++) &#123; int newNumIndex = end; while (newNumIndex - 1 &gt;= 0 &amp;&amp; arr[newNumIndex - 1] &gt; arr[newNumIndex]) &#123; swap(arr, newNumIndex - 1, newNumIndex); newNumIndex--; &#125; &#125;&#125;public static void insertSort2(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int N = arr.length; for (int end = 1; end &lt; N; end++) &#123; for (int pre = end - 1; pre &gt;= 0 &amp;&amp; arr[pre] &gt; arr[pre + 1]; pre--) &#123; swap(arr, pre, pre + 1); &#125; &#125;&#125; 归并排序 123456789101112131415161718192021222324252627282930public static void mergeSort(int[] arr, int left, int right) &#123; if (left == right) return; //分成两半 int mid = left + (right-left)/2; //左边排序 mergeSort(arr, left, mid); //右边排序 mergeSort(arr, mid+1, right); merge(arr, left, mid+1, right);&#125;static void merge(int[] arr, int leftPtr, int rightPtr, int rightBound) &#123; int mid = rightPtr - 1; int[] temp = new int[rightBound - leftPtr + 1]; int i = leftPtr; int j = rightPtr; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= rightBound) &#123; temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++]; &#125; while(i&lt;=mid) temp[k++] = arr[i++]; while(j&lt;=rightBound) temp[k++] = arr[j++]; for(int m=0; m&lt;temp.length; m++) arr[leftPtr +m] = temp[m];&#125; 快速排序 123456789101112131415161718192021222324public static void quickSort(int[] arr, int leftBound, int rightBound) &#123; if(leftBound &gt;= rightBound) return; int mid = partition(arr, leftBound, rightBound); quickSort(arr, leftBound, mid-1); quickSort(arr, mid+1, rightBound);&#125;static int partition(int[] arr, int leftBound, int rightBound) &#123; //adding the following code blocks is the random quick sort &#123; int random = leftBound + (int) (Math.random() * (rightBound - leftBound + 1)); swap(arr, random, rightBound); &#125; int pivot = arr[rightBound]; int left = leftBound; int right = rightBound - 1; while(left &lt;= right) &#123; while(left &lt;= right &amp;&amp; arr[left] &lt;= pivot) left ++; while(left &lt;= right &amp;&amp; arr[right] &gt; pivot) right --; if(left &lt; right) BaseCoding.swap(arr, left, right); &#125; BaseCoding.swap(arr, left, rightBound); return left;&#125; 计数排序 12345678910111213141516171819202122232425/** * 计数排序： * 遍历源数组找到最大值，通过这最大值创建一个计数数组； * 遍历源数组，在计数数组，源数组值位置，++； * 遍历计数数组，将数值大于0位置，以此写入源数组。 * * @param arr 原数组 */public static void countSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); &#125; int[] bucket = new int[max + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; bucket[arr[i]]++; &#125; int i = 0; for (int j = 0; j &lt; bucket.length; j++) &#123; while (bucket[j]-- &gt; 0) &#123; arr[i++] = j; &#125; &#125;&#125; 堆排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 堆排序: * * @param arr 源数组 */public static void heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; // O(N*logN) // for (int i = 0; i &lt; arr.length; i++) &#123; // heapInsert(arr, i); // &#125; // O(N) for (int i = arr.length - 1; i &gt;= 0; i--) &#123; heapify(arr, i, arr.length); &#125; int heapSize = arr.length; swap(arr, 0, --heapSize); // O(N*logN) while (heapSize &gt; 0) &#123; heapify(arr, 0, heapSize); swap(arr, 0, --heapSize); &#125;&#125;private static void heapify(int[] arr, int index, int heapSize) &#123; int left = (index &lt;&lt; 1) + 1; while (left &lt; heapSize) &#123; // 下方还有孩子的时候 // 两个孩子中，谁的值大，把下标给largest // 1）只有左孩子，left -&gt; largest // 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest // 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; // 父和较大的孩子之间，谁的值大，把下标给largest largest = arr[largest] &gt; arr[index] ? largest : index; if (largest == index) &#123; break; &#125; swap(arr, largest, index); index = largest; left = (index &lt;&lt; 1) + 1; &#125;&#125;private static void heapInsert(int[] arr, int index) &#123; while (arr[index] &gt; arr[(index - 1) / 2]) &#123; swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; &#125;&#125; 基数排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 基数排序 * @param arr */public static void radixSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; radixSort(arr, 0, arr.length - 1, maxbits(arr));&#125;private static int maxbits(int[] arr) &#123; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); &#125; int res = 0; while (max != 0) &#123; res++; max /= 10; &#125; return res;&#125;private static void radixSort(int[] arr, int L, int R, int digit) &#123; final int radix = 10; int i = 0, j = 0; int[] help = new int[R - L + 1]; for (int d = 1; d &lt;= digit; d++) &#123; int[] count = new int[radix]; // count[0..9] for (i = L; i &lt;= R; i++) &#123; j = getDigit(arr[i], d); count[j]++; &#125; for (i = 1; i &lt; radix; i++) &#123; count[i] = count[i] + count[i - 1]; &#125; for (i = R; i &gt;= L; i--) &#123; j = getDigit(arr[i], d); help[count[j] - 1] = arr[i]; count[j]--; &#125; for (i = L, j = 0; i &lt;= R; i++, j++) &#123; arr[i] = help[j]; &#125; &#125;&#125;public static int getDigit(int x, int d) &#123; return ((x / ((int) Math.pow(10, d - 1))) % 10);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://solitaire-12.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://solitaire-12.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":"织秋"},{"title":"Java|Java8","slug":"Java/Java8","date":"2024-03-18T12:14:55.000Z","updated":"2024-03-19T00:38:25.379Z","comments":true,"path":"2024/03/18/Java/Java8/","permalink":"https://solitaire-12.github.io/2024/03/18/Java/Java8/","excerpt":"","text":"java8实战汇总 Lambda表达式 Lambda表达式有三个部分，参数-&gt;主体 12(parameters) -&gt; expression(parameters) -&gt;&#123; statements; &#125; 123456789() -&gt; &#123;&#125; () -&gt; &quot;Raoul&quot;() -&gt; &#123;return &quot;Mario&quot;; &#125;// return是一个控制流语句。要使用此Lambda有效，需要使用花括号(Integer i) -&gt; return &quot;Alan&quot; + i; (Integer i) -&gt; &#123;return &quot;Alan&quot; + i;&#125;// “Iron Man”是一个表达式，不是一个语句。要使此Lambda有效，可以去除花括号和分号(String s) -&gt; &#123;&quot;Iron Man&quot;; &#125; (String s) -&gt; &quot;Iron Man&quot;; 演示代码 1 stream流的操作 ❏ 元素序列——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList与LinkedList）。但流的目的在于表达计算，比如你前面见到的filter、sorted和map。集合讲的是数据，流讲的是计算。后面几节会详细解释这个思想。 ❏ 源——流会使用一个提供数据的源，比如集合、数组或I/O资源。请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。 ❏ 数据处理操作——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，比如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可以并行执行。 流操作有两个重要的特点。 ❏ 流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，构成一个更大的流水线。这使得一些优化成为可能，比如处理延迟和短路。流水线的操作可以看作类似对数据源进行数据库查询。 ❏ 内部迭代——与集合使用迭代器进行显式迭代不同，流的迭代操作是在后台进行的。 示例代码 12345678910List&lt;Dish&gt; menu = Arrays.asList( new Dish(&quot;pork&quot;, false, 800, Dish.Type.MEAT), new Dish(&quot;beef&quot;, false, 700, Dish.Type.MEAT), new Dish(&quot;chicken&quot;, false, 400, Dish.Type.MEAT), new Dish(&quot;french fries&quot;, true, 530, Dish.Type.OTHER), new Dish(&quot;rice&quot;, true, 350, Dish.Type.OTHER), new Dish(&quot;season fruit&quot;, true, 120, Dish.Type.OTHER), new Dish(&quot;pizza&quot;, true, 550, Dish.Type.OTHER), new Dish(&quot;prawns&quot;, false, 300, Dish.Type.FISH), new Dish(&quot;salmon&quot;, false, 450, Dish.Type.FISH) ); 1234567891011121314151617181920212223242526272829public class Dish &#123; private final String name; private final boolean vegetarian; private final int calories; private final Type type; public Dish(String name, boolean vegetarian, int calories, Type type) &#123; this.name = name; this.vegetarian = vegetarian; this.calories = calories; this.type = type; &#125; public String getName() &#123; return name; &#125; public boolean isVegetarian() &#123; return vegetarian; &#125; public int getCalories() &#123; return calories; &#125; public Type getType() &#123; return type; &#125; @Override public String toString() &#123; return name; &#125; public enum Type &#123; MEAT, FISH, OTHER &#125;&#125; 初次使用stream 1234567// toList()是一个静态方法，需要 import static java.util.stream.Collectors.toList;// 要是不想导包，可以把toList() 改成 Collectors.toList()List&lt;String&gt; collect = menu.stream().filter(dish -&gt; dish.getCalories() &gt; 300) .map(Dish::getName) .limit(3) .collect(toList());System.out.println(collect); 上述中Dish::getName相当于Lambda d -&gt; d.getName() 筛选（filter）、提取（map）或截断（limit）功能 流的特性 只能遍历一遍 123Stream&lt;Dish&gt; stream = menu.stream();stream.forEach(System.out::println);stream.forEach(System.out::println); 内部迭代 1234567891011121314151617// 用for-each循环外部迭代ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();for (Dish dish : menu) &#123; names.add(dish.getName());&#125;/** * for-each结构是一个语法糖，其背后逻辑是一个迭代器，Iterator */ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();Iterator&lt;Dish&gt; iterator = menu.iterator();while (iterator.hasNext())&#123; names.add(iterator.next().getName());&#125;// stream的内部迭代List&lt;String&gt; names = menu.stream().map(Dish::getName).collect(toList());System.out.println(names); 重构测试 12345678List&lt;String&gt; highCaloricDishes = new ArrayList&lt;&gt;();Iterator&lt;String&gt; iterator = menu.iterator();while(iterator.hasNext()) &#123; Dish dish = iterator.next(); if(dish.getCalories() &gt; 300) &#123; highCaloricDishes.add(d.getName()); &#125;&#125; 1234List&lt;String&gt; highCaloricDishes = menu.stream() .filter(dish -&gt; dish.getCalories() &gt; 300) .collect(toList()); 流的操作 从上述代码中,不难看出，stream()之后跟着filter，map，limit，collect等操作，这是java.util.stream.Stream中的Stream接口定义的操作，它们可以分成两类。 ❏ 中间操作：filter、map和limit可以连成一条流水线； ❏终端操作： collect触发流水线执行并关闭它。 总结： 一个数据源 一个中间操作链，形成流水线 一个终端操作，执行流水线，并生成结果 中间操作 类型 操作 返回类型 操作参数 函数描述 作用 filter Stream&lt;T&gt; Predicate&lt;T&gt; T -&gt; boolean 筛选 map Stream&lt;R&gt; Function&lt;T,R&gt; T -&gt; R 获取 有状态-无界 limit Stream&lt;T&gt; 截选 有状态-无界 skip Stream&lt;T&gt; 跳过 有状态-无界 sorted Stream&lt;T&gt; Comparator&lt;T&gt; (T,T) -&gt; int 有状态-无界 distinct Stream&lt;T&gt; 去重 终端操作 类型 操作 返回类型 作用 forEach void 消费流中的每个元素并对其应用Lambda count long 返回流中元素的个数 collect (generic) 把流整合成一个集合，比如List，Map，甚至是Iterator anyMatch boolean noneMatch boolean allMatch boolean findAny Optinal&lt;T&gt; findFirst Optinal&lt;T&gt; 有状态-有界 reduce Optinal&lt;T&gt; 使用流 筛选 谓词筛选 12List&lt;Dish&gt; collect = menu.stream().filter(Dish::isVegetarian).collect(toList());System.out.println(collect); 筛选各异的元素 流还支持一个叫作distinct的方法，它会返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。例如，以下代码会筛选出列表中所有的偶数，并确保没有重复（使用equals方法进行比较) 12345List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);numbers.stream() .filter(i -&gt; i % 2 == 0) .distinct() .forEach(System.out::println); 切片 谓词切片 takeWhile和dropWhile，这两个是java9引入的新方法。 引入原因：倘若数据源已经按照热量从小到大排序了，还要筛选出热量小于320的数据，filter筛选会去遍历所有数据，这样比较消耗性能。所以引入了takeWhile和dropWhile。 takeWhile:通过谓词去选取出符合的数据，遭遇到第一个不符合的元素时，停止处理 dropWhile:和taskWhile是相反的操作，它会删除掉符合要求的数据 截短流 流支持limit(n)方法，该方法会返回另一个不超过给定长度的流。所需的长度作为参数传递给limit。如果流是有序的，则最多会返回前n个元素。 跳过元素 流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。请注意，limit(n)和skip(n)是互补的 映射 流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”） 流的扁平化 案例 对于一张单词表，如何返回一张列表，列出里面各不相同的字符? 例如，给定单词列表[“Hello”,“World”]，要返回列表[“H”, “e”, “l”, “o”, “W”, “r”, “d”] 尝试1：不行 1234567List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;);List&lt;String[]&gt; collect = words.stream() .map(word -&gt; word.split(&quot;&quot;)) .distinct() .collect(toList());System.out.println(&quot;words = &quot; + words); 尝试2：不行 12345678List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;);List&lt;Stream&lt;String&gt;&gt; collect = words.stream() .map(word -&gt; word.split(&quot;&quot;)) .map(Arrays::stream) .distinct() .collect(toList());System.out.println(&quot;words = &quot; + words); 解释Arrays::stream： 1234String[] arrayOfWords = &#123;&quot;Goodbye&quot;, &quot;World&quot;&#125;;List&lt;String&gt; streamOfwords = Arrays .stream(arrayOfWords) // 这是Stream&lt;String&gt;类型的 .collect(toList()); 尝试3：使用flatMap,成功 flatMap 12345678List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;);List&lt;String&gt; collect = words.stream() .map(word -&gt; word.split(&quot;&quot;)) .flatMap(Arrays::stream) .distinct() .collect(toList());System.out.println(&quot;words = &quot; + words); 查找和匹配 另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream API通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的工具。 anyMatch anyMatch方法可以回答“流中是否有一个元素能匹配给定的谓词” 比如↓，你可以用它来看看菜单里面是否有素食可选择 1234if(menu.stream().anyMatch(Dish::isVegetarian))&#123; System.out.println(&quot;The menu is (somewhat) vegetarian friendly! ! &quot;);&#125;//anyMatch方法返回一个boolean allMatch allMatch方法会看流中的元素是否都能匹配给定的谓词。 比如↓，你可以用它来看看菜品是否有利健康（即所有菜的热量都低于1000卡路里）： 1boolean isHealthy = menu.stream().allMatch(dish -&gt; dish.getCalories() &lt; 1000); noneMatch 它可以确保流中没有任何元素与给定的谓词匹配 比如↓，你可以用noneMatch重写前面的例子 1boolean isHealthy = menu.stream().noneMatch(dish -&gt; dish.getCalories() &gt;= 1000); findAny findAny方法将返回当前流中的任意元素。它可以与其他流操作结合使用 比如↓，你可能想找到一道素食菜肴。可以结合使用filter和findAny方法来实现这个查询 Optional 1Optional&lt;Dish&gt; dish = menu.stream().filter(Dish::isVegetarian).findAny(); findFirst 有些流由一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。对于这种流，你可能想要找到第一个元素。为此有一个findFirst方法，它的工作方式类似于findAny 123456List&lt;Integer&gt; someNumbers = Arrays.asList(1, 2, 3, 4, 5);Optional&lt;Integer&gt; firstSquareDivisibleByThree = someNumbers.stream() .map(n -&gt; n * n) .filter(n -&gt; n % 3 == 0) .findFirst(); // 9 归约-reduce 此类查询需要将流中所有元素反复结合起来，得到一个值，比如一个Integer。这样的查询可以被归类为归约操作（将流归约成一个值）。用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果 求和 在研究如何使用reduce方法之前，先来看看如何使用for-each循环来对数字列表中的元素求和 1234int sum = 0;for (int x : numbers) &#123; sum += x;&#125; 从上述代码看，for-each的求和过程并不复杂，那为什么还要引入reduce呢？ for-each代码复用率低，reduce对重复应用的模式做了抽象 12// 引入reduce求和int sum = numbers.stream().reduce(0,(a,b)-&gt;a+b); reduce接收的参数： 初始值，即对应for-each中的sum BinaryOperator&lt;T&gt;用来将两个元素结合起来产生一个新的值。上述代码中是一个lambda表达式 (a,b)-&gt;a+b 所以，当有累乘的业务时，我们可也写成： 1int product = numbers.stream().reduce(1,(a,b)-&gt;a*b); 引入java8静态方法sum进行求和 1int sum = numbers.stream().reduce(0,Integer::sum); 无初始值 reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象 1int sum = numbers.stream().reduce((a,b)-&gt;a+b); 最大值和最小值 12Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min); 归约方法的优势与并行化 从for-each循环求和来看，这种迭代求和方式一旦并行，问题时致命的。而reduce提供了更加安全，简便的实现方式。 123// use stream to sum all elements in parallel// 使用流对所有元素并行求和int sum = numbers.parallelStream().reduce(0,Integer::sum); 原始类型流特化 1int calories = menu.stream().map(Dish::getCalories).reduce(0, Integer::sum); 像上述代码，直接写成int calories = menu.stream().map(Dish::getCalories).sum();不是更好？但这却是不可能的，因为map方法生成的是Stream&lt;T&gt;类型的数据，没办法通过sum()方法来实现求和，不过Stream API提供了原始类型流特化，专门处理数值流的方法 IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本 映射到数值流 将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong 这些方法和前面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream IntStream还支持其他的方便方法，如max、min、average等 1234int sum = menu.stream() //Stream&lt;Dish&gt; .mapToInt(Dish::getCalories) // IntStream .sum(); // 如果IntStream是空的话，返回的是0 转换回对象流 同样，一旦有了数值流，你可能会想把它转换回非特化流。例如，IntStream上的操作只能产生原始整数：IntStream的map操作接受的Lambda必须接受int并返回int（一个IntUnaryOperator）。但是你可能想要生成另一类值，比如Dish 123IntStream intStream = menu.stream() .mapToInt(Dish::getCalories);Stream&lt;Integer&gt; stream = intStream.boxed(); 默认值OptionalInt 求和的那个例子很容易，因为它有一个默认值：0。但是，如果你要计算IntStream中的最大元素，就得换个法子了，因为0是错误的结果 Optional类，这是一个可以表示值存在或不存在的容器。Optional可以用Integer、String等参考类型来参数化。对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt、OptionalDouble和OptionalLong 123456OptionalInt maxCalories = menu.stream() .mapToInt(Dish::getCalories) .max();System.out.println(&quot;maxCalories = &quot; + maxCalories);int max = maxCalories.orElse(1); 数值范围 123456789IntStream.range(1, 10) .filter(value -&gt; value % 2 == 0) .forEach(System.out::println); // ↑结果：2，4，6，8IntStream.rangeClosed(1, 10) .filter(value -&gt; value % 2 == 0) .forEach(System.out::println); // ↑结果：2，4，6，8，10 // 总结range范围[x,y),rangeClosed范围[x,y] 尝试：获取勾股数 123456789101112131415161718192021Stream&lt;int[]&gt; pythagoreanTriples = IntStream.rangeClosed(1, 100).boxed() .flatMap(a -&gt; IntStream.rangeClosed(a, 100) .filter(b -&gt; Math.sqrt(a*a + b*b) % 1 == 0) .mapToObj( b -&gt; new int[]&#123;a, b, (int)Math.sqrt(a * a + b * b)&#125;) );pythagoreanTriples.limit(5).forEach(t-&gt;System.out.println(t[0]+&quot;,&quot;+ t[1] + &quot;,&quot; + t[2]));Stream&lt;double[]&gt; pythagoreanTriples = IntStream.rangeClosed(1, 100).boxed() .flatMap(a -&gt; IntStream.rangeClosed(a, 100) .mapToObj( b -&gt; new double[]&#123;a, b, Math.sqrt(a * a + b * b)&#125;) ) .filter(t -&gt; t[2] % 1 == 0);pythagoreanTriples.limit(5).forEach(t-&gt;System.out.println(t[0]+&quot;,&quot;+ t[1] + &quot;,&quot; + t[2])); Optional简介 Optional&lt;T&gt;类（java.util.Optional）是一个容器类，代表一个值存在或不存在。 在上述代码中，findAny存在什么元素都没有找到的可能，所以java8引入了Optional&lt;T&gt;,用来避免返回null的问题 测试 测试1：filter 根据示例代码，结合filter使用流筛选出前两个荤菜 12345List&lt;Dish&gt; collect = menu.stream() .filter(dish -&gt; dish.getType().equals(Dish.Type.MEAT)) .limit(2) .collect(toList()); 测试2：map 根据示例代码，结合映射 (1)给定一个数字列表，如何返回一个由每个数的平方构成的列表呢？例如，给定[1, 2, 3, 4, 5]，应该返回[1, 4, 9, 16,25]。 (2) 给定两个数字列表，如何返回所有的数对呢？例如，给定列表[1, 2, 3]和列表[3, 4]，应该返回[(1, 3), (1, 4), (2, 3), (2,4), (3, 3), (3, 4)]。为简单起见，你可以用有两个元素的数组来代表数对 (3) 如何扩展前一个例子，只返回总和能被3整除的数对 12345// (1)给定一个数字列表，如何返回一个由每个数的平方构成的列表呢？例如，给定[1, 2, 3, 4, 5]，应该返回[1, 4, 9, 16,25]。List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);List&lt;Integer&gt; collect = numbers.stream().map(n -&gt; n * n) .collect(toList());System.out.println(&quot;collect = &quot; + collect); 123456789// (2)给定两个数字列表，如何返回所有的数对呢？例如，给定列表[1, 2, 3]和列表[3, 4]，应该返回[(1, 3), (1, 4), (2, 3), (2,4), (3, 3), (3, 4)]。为简单起见，你可以用有两个元素的数组来代表数对List&lt;Integer&gt; numbers1 = Arrays.asList(1, 2, 3);List&lt;Integer&gt; numbers2 = Arrays.asList(3, 4);List&lt;int[]&gt; pairs = numbers1.stream() .flatMap(i -&gt; numbers2.stream() .map(j -&gt; new int[]&#123;i, j&#125;) ) .collect(toList()); 1234567891011// (3)如何扩展前一个例子，只返回总和能被3整除的数对List&lt;Integer&gt; numbers1 = Arrays.asList(1, 2, 3);List&lt;Integer&gt; numbers2 = Arrays.asList(3, 4);List&lt;int[]&gt; pairs = numbers1.stream() .flatMap(i -&gt; numbers2.stream() .filter(j -&gt; (i + j) % 3 == 0) .map(j -&gt; new int[]&#123;i, j&#125;) ) .collect(toList()); 测试3：reduce 根据示例代码，结合reduce，数一数流中有多少个菜 1int count = menu.stream().map(d -&gt; 1).reduce(0, (a, b) -&gt; a + b); 等价于 1long count = menu.stream().count(); 综合测试 源代码 123456789101112Trader raoul = new Trader(&quot;Raoul&quot;, &quot;Cambridge&quot;);Trader mario = new Trader(&quot;Mario&quot;, &quot;Milan&quot;);Trader alan = new Trader(&quot;Alan&quot;, &quot;Cambridge&quot;);Trader brian = new Trader(&quot;Brian&quot;, &quot;Cambridge&quot;);List&lt;Transaction&gt; transactions = Arrays.asList( new Transaction(brian, 2011, 300), new Transaction(raoul, 2012, 1000), new Transaction(raoul, 2011, 400), new Transaction(mario, 2012, 710), new Transaction(mario, 2012, 700), new Transaction(alan, 2012, 950)); 1234567891011121314151617181920212223242526272829303132333435363738394041public class Trader&#123; private final String name; private final String city; public Trader(String n, String c)&#123; this.name = n; this.city = c; &#125; public String getName()&#123; return this.name; &#125; public String getCity()&#123; return this.city; &#125; public String toString()&#123; return &quot;Trader:&quot;+this.name + &quot; in &quot; + this.city; &#125;&#125;public class Transaction&#123; private final Trader trader; private final int year; private final int value; public Transaction(Trader trader, int year, int value)&#123; this.trader = trader; this.year = year; this.value = value; &#125; public Trader getTrader()&#123; return this.trader; &#125; public int getYear()&#123; return this.year; &#125; public int getValue()&#123; return this.value; &#125; public String toString()&#123; return &quot;&#123;&quot; + this.trader + &quot;, &quot; + &quot;year: &quot;+this.year+&quot;, &quot; + &quot;value:&quot; + this.value +&quot;&#125;&quot;; &#125;&#125; 问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// (1) 找出2011年发生的所有交易，并按交易额排序（从低到高）。 List&lt;Transaction&gt; tr2011 = transactions.stream() .filter(transaction -&gt; transaction.getYear() == 2011) .sorted(Comparator.comparing(Transaction::getValue)) .collect(Collectors.toList()); System.out.println(&quot;tr2011 = &quot; + tr2011);// (2) 交易员都在哪些不同的城市工作过？ List&lt;String&gt; cities = transactions.stream() .map(transaction -&gt; transaction.getTrader().getCity()) .distinct() .collect(Collectors.toList());// Set&lt;String&gt; cities = transactions.stream()// .map(transaction -&gt; transaction.getTrader().getCity())// .collect(Collectors.toSet());// System.out.println(&quot;cities = &quot; + cities); System.out.println(&quot;cities = &quot; + cities);// (3) 查找所有来自于剑桥的交易员，并按姓名排序。 List&lt;Trader&gt; cambridgeTrader = transactions.stream() .map(Transaction::getTrader) .filter(trader -&gt; trader.getCity().equals(&quot;Cambridge&quot;)) .distinct() .sorted(Comparator.comparing(Trader::getName)) .collect(Collectors.toList()); System.out.println(&quot;cambridgeTrader = &quot; + cambridgeTrader);// (4) 返回所有交易员的姓名字符串，按字母顺序排序。// String reduce = transactions.stream()// .map(transaction -&gt; transaction.getTrader().getName())// .distinct()// .sorted()// .reduce(&quot;&quot;, (n1, n2) -&gt; n1 + n2); String reduce = transactions.stream() .map(transaction -&gt; transaction.getTrader().getName()) .distinct() .sorted() .collect(Collectors.joining()); System.out.println(&quot;reduce = &quot; + reduce);// (5) 有没有交易员是在米兰工作的？ boolean anyOneInMilan = transactions.stream() .anyMatch(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Milan&quot;)); System.out.println(&quot;anyOneInMilan = &quot; + anyOneInMilan);// (6) 打印生活在剑桥的交易员的所有交易额。 transactions.stream() .filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;)) .map(Transaction::getValue) .forEach(System.out::println);// (7) 所有交易中，最高的交易额是多少？ Optional&lt;Integer&gt; max = transactions.stream() .map(Transaction::getValue) .reduce(Integer::max); Optional&lt;Transaction&gt; max1 = transactions.stream().max(Comparator.comparing(Transaction::getValue)); System.out.println(&quot;max = &quot; + max); System.out.println(&quot;max1 = &quot; + max1);// (8) 找到交易额最小的交易。 Optional&lt;Integer&gt; min = transactions.stream() .map(Transaction::getValue) .reduce(Integer::min); Optional&lt;Transaction&gt; min1 = transactions.stream().min(Comparator.comparing(Transaction::getValue)); System.out.println(&quot;min = &quot; + min); System.out.println(&quot;min1 = &quot; + min1); 测试树形数据 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) &#123; ArrayList&lt;Zz&gt; source = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 10; i++) &#123; Zz z1 = new Zz(); z1.setId(Long.valueOf(i)); int i1 = i % 3 == 2 ? i - 1 : 0; z1.setPid(Long.valueOf(i1)); source.add(z1); &#125; System.out.println(source); List&lt;Zz&gt; tree = source.stream() .filter(item -&gt; item.getPid().equals(0)) .map(item -&gt; &#123; List&lt;Zz&gt; children = new ArrayList&lt;&gt;(); item.setChildren(children); getChildren(children, item.getId(), source); return item; &#125;) .collect(Collectors.toList()); System.out.println(tree);&#125;private static void getChildren(List&lt;Zz&gt; children, Long id, ArrayList&lt;Zz&gt; source) &#123; source.stream() .filter(item -&gt; item.getPid().equals(id)) .map(item -&gt; &#123; children.add(item); List&lt;Zz&gt; child = new ArrayList&lt;&gt;(); item.setChildren(child); getChildren(children, item.getId(), source); return item; &#125;) .collect(Collectors.toList());&#125; 函数式编程Function 待续","categories":[{"name":"Java","slug":"Java","permalink":"https://solitaire-12.github.io/categories/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://solitaire-12.github.io/tags/Java8/"}]},{"title":"Java|JVM","slug":"Java/JVM","date":"2024-03-18T12:10:55.000Z","updated":"2024-03-19T00:38:37.182Z","comments":true,"path":"2024/03/18/Java/JVM/","permalink":"https://solitaire-12.github.io/2024/03/18/Java/JVM/","excerpt":"","text":"类加载 加载过程 将java文件编译成class字节码文件，通过类加载器写入到JVM虚拟机运行时数据区中。 类加载流程 ​ 类加载需要经历五个阶段，分别是加载，验证，准备，解析，初始化。其中加载，验证，准备，初始化这四个阶段发生的顺序时确定的，而解析阶段时不一定的。它在某些情况下可以在初始化阶段之后开始，这是为了支持java的运行时绑定（也称做动态绑定）。另外，这些阶段都是按顺序开始，而非按顺序进行或者完成。 类加载器 双亲委派机制： ​ 当某个类加载器需要加载某个class文件时，它首先会把这个任务委派给它的父级加载器，递归到顶级加载器。随后进行加载，倘若加载失败，由子类加载器进行加载。可以保证同一个class只被加载一次。 运行时数据区 绿色线程共享，蓝色线程私有 JDK6：有永久代，静态变量存放在永久代上 JDK7：有永久代，但是已经把运行时常量池，常量池存放在方法区中了，逐渐的减少永久代的使用。 JDK8：无永久代，运行是常量池、类常量池都保存在元数据区，也就是元空间 。但是字符串常量池任然放在堆上。需要注意的是：元空间占用的是本地内存。 内存模型 程序计数器 线程私有。Java虚拟机执行多线程时，由于CPU时间片限制，线程执行具有随机性，操作系统会一直切换执行不同指令，我们需要把切换时候线程执行的位置存入到PC寄存器中，等切回来的时候能够回到原来的位置继续执行。 任何时候，每个Java虚拟机都在执行单个方法的代码，即该线程的当前方法。如果该方法不是Native方法，即PC寄存器会记录当前正在执行的java虚拟机指令的地址，如果线程当前执行的方法是本地的，那么java虚拟机的PC寄存器的值就是Undefined。 程序计数器是唯一一个不会出现OOM的区域。 本地方法栈 线程私有。提供虚拟机使用到本地Native方法，本地方法栈和虚拟机栈在有的虚拟机是合在一起的，例如Hot Spot虚拟机。 栈 线程私有，每个线程都有一个与线程同时创建的私有的虚拟机栈。虚拟机栈中存储栈帧，每个被线程调用的方法都会产生一个栈帧，栈帧中保存一个方法的状态信息，例如局部变量(存储方法内的局部变量)、操作数帧(用来计算临时存放变量)、方法出口(记录哪个方法的本方法)、动态链接(存放方法的元信息)等。调用一个方法就是执行一个栈帧的过程，一个方法调用完成，对应的栈帧就会出栈。 如果线程执行所需栈深度大于Java虚拟机栈深度，就会抛出StackOverFlowError，其实方法调用的过程就是入栈和出栈的过程，如果一致入栈不出栈，就容易发生异常（递归调用） 如果Java虚拟机栈可以动态扩展，但是扩展大小的时候无法申请到足够的内存，则会抛出OutOfMemoryError。 堆 线程共享。堆是java虚拟机管理内存最大的一块，在虚拟机启动时创建，所有线程共享，堆中的对象永远不会被显式释放，必须由GC回收，所以GC也主要回收堆中的对象实例，我们平常讨论的垃圾回收就是回收堆内存。堆可以处于物理上不连续的空间，可以固定大小，也可以动态扩展，通过参数-Xms和-Xmx两个参数控制堆的最小值和最大值。这里是**OOM异常的易发区** 分成新生代和老年代。 新生代又分成1个Eden区和2个Survivor区，默认比例8:1:1 绝大多数对象在Eden区生成，**当Eden区填满，或者不满足新建一个对象时，触发Young GC。**将存活的对象放进Survivor。Survivor分成两块，用于每次Young GC时，将存活的对象统统复制进空的幸存区，将有数据的那块清空。 当一个对象在两个survivor区之间交换了一定次数之后，将对象拷贝到老年代。这个数量用-XX:MaxTenuringThreshold配置，默认值是15 方法区 线程共享，在虚拟机启动时创建，存储已经被虚拟机加载的类信息、常量、静态变量，即经编译器之后的数据(运行时常量池[存放class文件元信息描述，编译后的代码数据，引用类型数据，类文件常量池]、属性和方法数据)，以及方法和构造函数的代码，包括在类和实例初始化以及接口初始化使用的特殊方法，方法区在逻辑上是堆的一部分，但是它又有另一个别名叫非堆，目的是与堆区分开。方法区可以是固定大小，也可以根据计算需要进行扩展。如果方法区的内存无法满足分配请求时也会抛出OutOfMemoryError。 永久代 元空间 JDK8使用元空间代替永久代（类元信息，字段，静态属性，方法，常量），同时运行时常量池等都移动到了元空间，字符串常量池在堆中。 元空间在本地内存中，它独立于运行时数据区，也不是Java虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受堆大小影响。但是会受到本机总内存大小以及处理器寻址空间的限制，因此它也可能抛出OOM异常。 垃圾回收 找到垃圾 ​ 两种方法判断对象是否需要销毁： 引用计数法 ​ 为对象添加一个引用计数器，每当对象被引用，引用计数器加1。当引用失效，减一。计数器为零，代表该对象可以被回收。 ​ **问题：**循环引用问题 可达性分析 ​ 通过一系列&quot;GC Roots&quot;的根节点开始，沿用引用链进行搜索，凡是在引用链上的，都不会被回收。 ​ 解决了循环依赖问题。 垃圾回收算法-GC 标记-清除算法 首先在堆内存扫描一遍，然后把灰色区域的对象标记 继续扫描，扫描的同时将被标记的对象统一回收回收后： 回收之后，产生大量不连续的内存碎片。 需要进行标记，清除两个过程，效率不高。 复制算法 ​ 将内存区域分成大小一样的两块，每次只是用一块，gc之后将对象复制到另一块，然后一次性清理掉这块内存。 回收前： 回收后： 复制算法的缺点是牺牲了一半的内存空间，有点浪费。复制算法在JVM中的体现就是：java堆内存做了几次划分，Hot Spot虚拟机中Eden和Survivor的比例是Eden:S0:S1=8:1:1，将Survivor分成了两个区域S0和S1来进行赋值，这种做法是为了弥补原始复制算法直接将一半空间作为空闲空间的浪费。IBM公司表示：Young区有98%的对象都是朝生夕死的，生命周期极短，所以说一次GC下来存活的对象很少，所以没必要用一半空间来复制。 标记-整理算法 ​ 标记-整理算法就是为了老年代而设计的算法，标记-整理算法和标记-清除算法的区别在最后一步，标记-整理不会直接对对象清理，而是进行移动，将存活对象移动到一端，然后清理掉边界以外的对象。 回收前： 回收后： 分代收集算法 ​ 目前主流的商业虚拟机都是采用分代收集算法，这种算法就是上面三种算法的结合。新生代采用复制算法，老年代采用标记-整理或标记-清除算法。 垃圾收集器 Serial 和Serial Old 收集器 Serial 单线程，GC时Stop The World（STW），暂停所有用户线程。 Serial Old 单线程，作用与老年代。标记整理算法 ​ 优点：单线程收集效率高 ​ 缺点：需要STW，暂停所有用户线程 ​ 算法： Serial采用复制算法 ；Serial Old采用标记-整理算法 ParNew收集器 ​ ParNew收集器是Serial收集器的多线程版本，实现并行收集， 原理跟Serial一致（并行指的是多个GC线程并行，但是用户线程还是暂停，并发指的是用户线程和GC线程同时执行）。ParNew默认开启和CPU个数相同的线程数进行回收。 ​ 优点：在多CPU时，比Serial的效率高。 ​ 缺点：还是需要STW，单CPU时比Serial效率低 ​ 算法：复制算法 Parallel Scavenge 收集器 新生代收集器，也是复制算法，和ParNew一样并行的多线程收集器，更关注系统的吞吐量[吞吐量=(运行用户代码的时间) / (运行用户代码的时间+ GC 时间) ]Parallel Scavenge 提供了两个参数用于精确控制吞吐量： 123456789-XX:MaxGCPauseMillis //GC最大停顿毫秒数，必须大于0-XX:GCTimeRation //设置吞吐量大小，大于0小于100，默认值为99-XX:+UseAdaptiveSizePolicy //开启自适应策略//你会不会觉得把MaxGCPauseMillis设置小点就会让GC速度变快？//答案是否定的，如果设置时间过小，Parallel Scavenge 会牺牲吞吐量和新生代空间来交换，//比如新生代400Mb需要GC时间为100ms，设置成50ms了，那么就会把新生代调小为200Mb，这样肯定时间就降下来了，//然而这种操作可能会降低吞吐量，原先10s触发一次GC，每次100ms，// 修改时间后变成5s触发一次GC，每次70ms，那么10ms触发两次GC的时间变成了140ms，吞吐量反而降低。 Parallel Old 收集器 是Parallel Scavenge 的老年代版本，使用标记-整理算法，因为Parallel Scavenge 无法和CMS搭配使用，所以只能和Serial Old。自从Parallel Old出现，就有了Parallel Scavenge +Parallel Old的组合，这是JDK8使用的，注重吞吐量的一组收集器。 CMS收集器 这是优化GC停顿时间为目标的收集器，并发回收（仍然需要STW，但是时间很短）。通过-XX:+UseMarkSweepGC启用。CMS基于标记-清除算法实现。整个过程分为四步： 初始标记：需要STW，标记GC Roots对象。 并发标记：这个阶段可以和用户线程一起进行，分为三步： 根据第一步找到的GC Roots开始搜索跟GC Roots相连的对象。 预清理：处理并发标记之后发生变化的对象。 可被终止的预清理：有一个abort 触发条件，该阶段存在的目的是希望能发生一次Young GC，来减少Young区对象数量，降低重新标记的工作量，因为重新标记会扫描整个堆内空间，可以通过参数-XX:+CMSScavangeBeforeRemark 控制在重新标记前发生一次Young GC，默认为false。 重新标记：需要STW，这个阶段是为了修正在阶段2标记之后产生变化的对象。 并发清除：和用户线程同时进行，开始正式清理垃圾，此阶段产生的垃圾留待下次清除。 优点：并发收集，低停顿 缺点：产生大量碎片，并发阶段会降低吞吐量 G1收集器 ​ G1是以优化GC停顿时间为目标的收集器，它尝试以高概率满足GC停顿时间为目标，同时实现高吞吐量。在G1中，将堆的整个内存布局做了修改，在G1中整个堆划分为多个大小相等的独立区域Region，虽然在逻辑上还保留了新生代和老年代，但是物理上已经隔离了，G1的堆内存布局如下图 ： 上图智能柜被划分成一组大小相同的Region，每个Region都是连续的虚拟内存范围，G1可以知道哪个Region区域内大部分是空的，这样就可以在每次允许的收集时间内优先回收价值最大的Region区域（根据回收所获得的空间大小以及回收需要的时间综合考虑）所以这就是G1叫做Garbage-First的原因。G1是JDK8默认的垃圾收集器。G1的工作流程和CMS很相似，区别在最后的步骤。也有四步： 初始标记：需要STW，标记下GC Roots关联的对象，并且修改TAMS（Next Top at Mark Start）的值，使得下一阶段并发运行时，能在正确可用的Region中创建对象。 并发标记：和CMS一样，主要是进行GC Roots的向下搜索，找出存活对象进行标记。 最终标记：需要STW，和CMS一样，这个阶段是修正并发标记期间因用户程序运行而导致变动的对象。 筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间制定回收计划。 G1的第一个重点是为运行需要大堆且GC延迟有限的应用程序的用户提供解决方案，这就意味着堆大小约为6G或更大，并且稳定且可预测的暂停时间低于0.5秒。如果应用程序具备以下特性，可以考虑切换到G1收集器： 超过50%的Java堆被实时数据占用 对象分配率或提升率差异很大 当前应用程序GC停顿时间超过0.5秒，又想缩短停顿时间 各收集对比 收集器 串行/并行/并发 新生代/老年代 算法 目标 适用场景 Serial 串行 新生代 复制 响应速度优先 单CPU环境下的Client模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单CPU环境下的Client模式，CMS的后备预案 ParNew 并行 新生代 复制 响应速度优先 多CPU环境时在Server模式下与CMS配合使用 Parallel Scavenge 并行 新生代 复制 吞吐量优先 在后台运算且不需要太多交互的任务 Parallel 并行 老年代 标记-整理 吞吐量优先 在后台运算且不需要太多交互的任务 CMS 并发 老年代 标记-清除 响应速度优先 集中在互联网网站 或 B/S系统服务端中的Java应用 G1 并发 兼顾 标记-整理+复制 响应速度优先 面向服务端应用 串行收集器：Serial和Serial Old单线程收集，适用于内存较小的嵌入式设备。 并行收集器【吞吐量优先】：Parallel Scavenge + Parallel Old，适用于科学计算、后台处理等场景。 并发收集器【GC停顿时间优先】：CMS和G1，适用于对时间有要求的场景，例如Web应用。 调优 所谓调优就是设置一个合理的JVM参数，适配当前系统运行。 参数 可以分成三类：标准参数，-X参数，-XX参数 标准参数 ​ 以&quot;-&quot;开头的参数称为标准参数，是任何一个JDK版本都支持的，比较稳定，不会随版本更新和改变。例如-version,-help,-server。 -X参数 ​ 以-X开头的参数是在特定版本HotSpot支持的命令。JDK版本变化之后，参数可能变化，这个参数用的较少。 -XX参数 -XX是不稳定的参数，也是主要参数，分为Boolean类型和非Boolean类型。 Boolean类型 -XX:[+-]&lt;name&gt;：+或-表示启用或者禁用name属性 123456表示启用CMS垃圾收集器-XX:+UseConcMarkSweepGC表示启用G1垃圾收集器-XX:+UseG1GC表示打印出所有的JVM参数信息-XX:+PrintFlagsFinal 非Boolean类型 -XX&lt;name&gt;=&lt;value&gt;：name表示属性，value表示属性对应的值 12设置最大永久代空间大小为5M-XX:MaxMetaspaceSize=5M 其他 123-Xms1000 等价于 -XX:InitialHeapSize=1000-Xmx1000 等价于 -XX:MaxHeapSize=1000-Xss1000 等价于 -XX:ThreadStackSize=1000 常用参数 设置 说明 -XX:ClCompilerCount=3 最大并行编译数，大于1时可以提高编译速度，但会影响系统稳定性 -XX:InitialHeapSize=100m 初始堆大小，可以简写为-Xms100 -XX:MaxHeapSize 最大堆大小，可以简写为-Xmx100 -XX:NewSize=20m 设置年轻代大小 -XX:MaxNewSize 设置年轻代最大值 -XX:OldSize=50m 设置老年代大小 -XX:MetaspaceSize=50m 设置方法区大小，JDK8才有，用元空间代替方法区 -XX:+UseParallelGC 设置Parallel Scavenge作为新生代收集器系统默认会选择Parallel Old作为老年代收集器 -XX:NewRatio 新生代和老年代的比值比如 -XX:NewRatio=4表示新生代：老年代=1：4 -XX:SurvivorRatio 表示Survivor区和Eden区的比值比如-XX:SurvivorRatio=8表示（S0或S1):Eden=1:8 命令监控工具 待续 参考： Java SE Specifications (oracle.com) JVM万字总结 - 掘金 (juejin.cn) 【JVM系列8】JVM知识点总览 - 掘金 (juejin.cn) JVM8内存模型_jdk8内存模型_余生之君的博客-CSDN博客 JVM内存模型总结，有各版本JDK对比、有元空间OOM监控案例、有Java版虚拟机，综合实践学习！ - 小傅哥 - 博客园 (cnblogs.com) https://zhuanlan.zhihu.com/p/297001119","categories":[{"name":"Java","slug":"Java","permalink":"https://solitaire-12.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://solitaire-12.github.io/tags/JVM/"}]},{"title":"内网穿透","slug":"Server/内网穿透","date":"2024-03-18T09:05:07.000Z","updated":"2024-03-19T06:41:52.244Z","comments":true,"path":"2024/03/18/Server/内网穿透/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"环境： 服务端阿里云： CentOS 8.5.2111 客户端：windows 11 / windows 10 frp 0.42 第一步 官网下载frp软件 笔者使用的版本：链接：https://pan.baidu.com/s/1cjmUiOY8iRIywx6whkhRdg 提取码：gatr 第二步 服务端： 将 frp_0.42.0_linux_amd64.tar.gz压缩包传给linux 进入到文件存放目录 123tar -zxvf frp_0.42.0_linux_amd64.tar.gzcd frp_0.42.0_linux_amd64/vi frps.ini 💬提醒：只要bind_port的7000端口没被占用，一般不建议修改。 12./frps -c frps.ini #临时启动nohup ./frps -c frps.ini &amp; #永久启动 客户端： 解压 frp_0.42.0_windows_amd64.zip ，注意关闭一下杀毒软件。 打开之后，修改frpc.ini文件。 💬解释： 12[ssh]定义一个使用 [type] 协议的url: [local_ip]:[local_port]被[server_addr]:[remote_port]代理了。即：用户访问 [server_addr]:[remote_port] 后，服务器&quot;跳转&quot;到 [local_ip]:[local_port] 启动 12# 进入cmdfrpc.exe -c frpc.ini ⚠️注意：假如你将frpc.ini中的remote_port和frps.ini中的dashboard_port配置成一样的话，启动客户端的时候，就会出现 [ssh] start error: port unavailable。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|项目部署","slug":"Server/项目上线","date":"2024-03-18T08:25:07.000Z","updated":"2024-03-18T09:02:45.468Z","comments":true,"path":"2024/03/18/Server/项目上线/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/","excerpt":"","text":"环境 系统：Centos 8.4.2105 docker : 24.0.5 nginx: nginx/1.25.1 后端 宿主机安装 后端达成jar包上传到服务器 ps -ef | grep java查看有没有在运行的java项目，要是端口冲突的话，直接kill java -jar没有问题之后，nohup java -jar x.jar &gt; x.log 2&gt;&amp;1 &amp; 就可以。 docker内部 创建Dockerfile vi Dockerfile 1234FROM openjdk:8ADD 18080.jar test.jarEXPOSE 18080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;test.jar&quot;] 描述： FROM openjdk:8:拉取基础镜像 ADD 18080.jar test.jar：将18080.jar复制到镜像中，重命名成test.jar EXPOSE 18080:声明端口，一般指定的是jar运行端口 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;test.jar&quot;]：容器启动之后执行的命令 MAINTAINER xx: 添加作者信息 构建镜像 1docker build -t test . 描述： test：镜像名称 .：表示Dockerfile在当前目录下 查看镜像 1docker images 运行进行 1docker run -d --restart=always --name test -p 8080:18080 test 描述： -d：表示后台运行容器 --restart=always：代表容器在停止或者服务器开机之后会自动重启 --name test:命名成test -p 8080:18080：端口映射 [宿主机端口]:[容器端口] test:运行的镜像 更新jar包 1docker cp new.jar [容器id]:/test.jar 随后，重启容器 Docker部署可执行jar包-阿里云开发者社区 (aliyun.com) 前端 项目打包 打包之后将项目放在挂载的html目录下,详情查看docker安装nginx | 线上跳转↗️ 挂载项目： 将项目挂载到文件夹a里边 配置nginx 修改前的配置文件： 修改后的配置文件： 注意事项 要是jar运行在宿主机(安装dokcer的服务器)上面的话，建议server_name修改成172.17.0.1(这个地址是安装docker之后，默认生成的网桥)。用ifconfig -a可以查看Linux 的IP地址 不要在 localtion / &#123;&#125;这块里边取写 proxy_pass，会网页都打不开。 倘若有第二个前端项目的话，同样html目录下面创建挂载文件夹并把文件存放在内。然后在写一个localtion块，修改一下listen端口。例如： 问题排查： 1.运行jar包服务器卡死 环境： 系统：8.5.2111 配置：2核2G 目标服务： Minio，frp，docker，nginx，redis，mysql，前端，后端 场景： 服务器运行着Minio，frp，nginx，docker，redis-docker，mysql-docker，前端。将后端jar包上传服务器，nohup java -jar xx &amp;连接服务器的xshell敲命令执行卡顿，无法重连xshell，随后服务器卡死。 问题排查： 观察到xshell命令还是能敲上的，但是键盘敲击之后，xshell界面很久才能回显，执行也要很久很久，而且重连xshell也是很长时间连接不上。 类似这种反应时间很长，系统出现&quot;死机&quot;的现象，多半是内存不足。 为啥会内存不足呢？ 重启服务器之后，重新配置好需要的环境，不运行jar包。查看top命令： 观察其中的进程，注意到有个mysqld占用了22.4%的存，整台服务器的内存是2G，实际运行起来指定没有2048M的，以及其他一些系统支持的，算亏损10%，空闲内存实际约为1850M。刨去mysqld默认占用的1G，实际占用的450M。要想维系整个系统的开支，可用内存也就1G左右。 将jar在开发环境上运行，观察到其占用了开发电脑1000-1300M的内存资源。 解决方案也就呼之欲出了： 配置java -jarJVM的参数，限定其内存大小。例如： 1java -Xmx512M -jar xxx.jar 从mysqld上解决，参考1 参考2 它是Performance Schema 的大小，默认配置是1G。 此时基本解决内存不足问题。 2.jar包运行，CPU飙升至190% 环境： 系统：8.5.2111 配置：2核2G 目标服务器任务进程： Minio，frp，docker，nginx，redis，mysql，前端，后端 场景： 服务器运行着Minio，frp，nginx，docker，redis-docker，mysql-docker，前端。将后端jar包上传服务器，nohup java -jar xx &amp;后，top指令监测到cpu处在190%附近。 问题排查： 通过 命令，查看该进程下的线程资源占用情况。 1ps -mp pid -o THREAD,tid,time 将其中%CPU高的线程TID进行转码 1print &quot;%x\\n&quot; TID 通过查看cpu占用很高的线程状态 1jstack PID | grep [0xTID:第二部转码出来的tid] 如果线程还处在Runnable状态，那么通过jstack去找到详情。如果问题指向代码，那就去修改。 到此基本解决。 当然，还有个情况就是，正常启动直接拉爆，随后又静默到1%的，查线程高占用的都停止了，这种情况下，倘若后期还有MQ什么的其他服务要用的话，建议将升级到4核cpu。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"部署","slug":"部署","permalink":"https://solitaire-12.github.io/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"linux|docker安装nginx","slug":"Server/docker安装nginx","date":"2024-03-18T08:23:07.000Z","updated":"2024-03-18T08:33:54.888Z","comments":true,"path":"2024/03/18/Server/docker安装nginx/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker%E5%AE%89%E8%A3%85nginx/","excerpt":"","text":"centos8.5.2111 拉取镜像 1docker pull nginx 创建Nginx挂载目录 123mkdir -p mytools/nginx/confmkdir -p mytools/nginx/logmkdir -p mytools/nginx/html 将容器中的配置复制到宿主机 12345678# 生成容器docker run --name nginx -p 9001:80 -d nginx# 将容器nginx.conf文件复制到宿主机docker cp nginx:/etc/nginx/nginx.conf /mytools/nginx/conf/nginx.conf# 将容器conf.d文件夹下内容复制到宿主机docker cp nginx:/etc/nginx/conf.d /mytools/nginx/conf/conf.d# 将容器中的html文件夹复制到宿主机docker cp nginx:/usr/share/nginx/html /mytools/nginx/ 正式启动nginx 12345678docker run \\-p 9002:80 \\--name nginx \\-v /mytools/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /mytools/nginx/conf/conf.d:/etc/nginx/conf.d \\-v /mytools/nginx/log:/var/log/nginx \\-v /mytools/nginx/html:/usr/share/nginx/html \\-d nginx:latest 查看运行状态 1curl localhost:9002 公网IP访问 修改html查看运行状态 查看是否生效 1docker restart nginx","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|docker安装RabbitMQ","slug":"Server/docker安装RabbitMQ","date":"2024-03-18T08:23:07.000Z","updated":"2024-03-18T08:40:58.750Z","comments":true,"path":"2024/03/18/Server/docker安装RabbitMQ/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker%E5%AE%89%E8%A3%85RabbitMQ/","excerpt":"","text":"工欲善其事必先利其器：windows下载erlang 下载RabbitMQ 下载RabbitMQ源码 Docker安装RabbitMQ 12345678910111213# 查找rabbitmq镜像docker search rabbitmq# pull镜像docker pull rabbitmq# 运行mq ## -p [暴露的宿主机端口]:[docker内部端口]docker run -d --hostname rabbit-test --name rabbit \\-p 15672:15672 -p 5672:5672 rabbitmq# 进入mq镜像docker exec -it [容器id] /bin/bash# 运行rabbitmq-plugins enable rabbitmq_management# 默认账号密码：guest：guest","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|docker安装redis","slug":"Server/docker安装redis","date":"2024-03-18T08:22:07.000Z","updated":"2024-03-18T08:31:58.663Z","comments":true,"path":"2024/03/18/Server/docker安装redis/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker%E5%AE%89%E8%A3%85redis/","excerpt":"","text":"centos 8.5.2111 拉取redis镜像 1docker pull redis 准备redis的配置文件 官网： redis 6.0.6 下载 – Redis中国用户组（CRUG） 把redis.conf上传到服务器redis安装的位置 配置redis.conf文件 bind 127.0.0.1 #注释掉这部分，使redis可以外部访问 daemonize no#用守护线程的方式启动 requirepass 你的密码#给redis设置密码 appendonly yes#redis持久化 默认是no tcp-keepalive 300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300 123456789101112#注释掉这部分，使redis可以外部访问bind 127.0.0.1 #用守护线程的方式启动daemonize no#给redis设置密码requirepass 你的密码#redis持久化 默认是noappendonly yes#防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300tcp-keepalive 300 # :/[findword] 在vi命令中寻找文字，最好加个空格去找 创建本地与docker映射目录 12mkdir mytools/redismkdir mytools/redis/data 把上述的redis.conf复制到redis目录下 启动 1sudo docker run -p 6379:6379 --name redis -v /mytools/redis/redis.conf:/etc/redis/redis.conf -v /mytools/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes -p 6379:6379:把容器内的6379端口映射到宿主机6379端口-v /data/redis/redis.conf:/etc/redis/redis.conf：把宿主机配置好的redis.conf放到容器内的这个位置中-v /data/redis/data:/data：把redis持久化的数据在宿主机内显示，做数据备份redis-server /etc/redis/redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动–appendonly yes：redis启动后数据持久化 查看日志：docker logs redis","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|docker安装minio","slug":"Server/minio","date":"2024-03-18T08:22:07.000Z","updated":"2024-03-18T09:10:40.271Z","comments":true,"path":"2024/03/18/Server/minio/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/minio/","excerpt":"","text":"环境 centos 8.5 创建minio文件夹 12mkdir /mytools/miniocd /mytools/minio wget下载minio 1wget https://dl.minio.io/server/minio/release/linux-amd64/minio 创建日志，授权 12touch minio.logchmod 777 minio 启动minio 12# 后面跟着的是静态文件挂载目录./minio server /opt/minio/data **问题原因：**笔者编写文档之前，运行过minio，这里显示端口占用问题，kill一下进程就好了 红字：警告:检测到默认凭据’minioadmin:minioadmin’，我们建议您使用’MINIO_ROOT_USER’和’MINIO_ROOT_PASSWORD’环境变量更改这些值 配置环境变量 12345vim /etc/profile export MINIO_ROOT_USER=fileadmin export MINIO_ROOT_PASSWORD=fileadminsource /etc/profile 指定端口重启minio 12# 有需求自己换成自己的存放目录./minio server /opt/minio/data --console-address &quot;:9050&quot; 设置后台启动 12345vim start.shnohup /mytools/minio/minio server /opt/minio/data --console-address &quot;:9050&quot; &gt; /opt/minio/minio.log 2&gt;&amp;1 &amp;sh start.sh 问题： minio服务部署在云端时，配置服务网站要用公网ip，不然没办法回显","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|docker安装mysql8","slug":"Server/docker安装mysql8","date":"2024-03-18T08:21:07.000Z","updated":"2024-03-18T08:29:42.068Z","comments":true,"path":"2024/03/18/Server/docker安装mysql8/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker%E5%AE%89%E8%A3%85mysql8/","excerpt":"","text":"拉取镜像 1docker pull mysql:8.0.23 检查镜像 1docker images 启动镜像 1234567891011sudo docker run -p 3306:3306 --name mysql \\-v /usr/local/docker/mysql/mysql-files:/var/lib/mysql-files \\-v /usr/local/docker/mysql/conf:/etc/mysql \\-v /usr/local/docker/mysql/logs:/var/log/mysql \\-v /usr/local/docker/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:8.0.23docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql 1docker logs -f mysql #查看启动日志 进入容器 1docker exec -it mysql bash 方法二 下载mysql 1docker pull mysql:8.0.23 创建文件夹做挂载 12345//创建文件夹做挂载mkdir -p /mydata/mysql/confmkdir /mydata/mysql/data//创建my.cnf配置文件vi /mydata/mysql/conf/my.cnf my.cnf添加如下内容 123456789101112131415[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_passwordsecure_file_priv=/var/lib/mysqlexpire_logs_days=7sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTIONmax_connections=1000lower_case_table_names=1 [client]default-character-set=utf8 [mysql]default-character-set=utf8 注意： 你的数据库要是从本地windows上迁移到linux的话，lower_case_table_names=1,这个一定要加上，不然的话要重新部署，很麻烦 创建容器 12345678910docker run \\--restart=always \\--privileged=true \\-p 3306:3306 --name mysql \\-v /mydata/mysql/log:/var/log/mysql \\-v /mydata/mysql/data:/var/lib/mysql \\-v /mydata/mysql/conf/my.cnf:/etc/mysql/my.cnf \\-v /mydata/mysql/conf/conf.d:/etc/mysql/conf.d \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:8.0 进入容器 1docker exec -it mysql bash 进入mysql 123mysql -u root -p# 查看数据库show databases","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|安装Git/Maven","slug":"Server/GitMaven","date":"2024-03-18T08:20:07.000Z","updated":"2024-03-18T08:23:14.809Z","comments":true,"path":"2024/03/18/Server/GitMaven/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/GitMaven/","excerpt":"","text":"安装Git 1yum install -y git 校验安装结果 1git --version 安装maven 创建存放maven的文件夹 1mkdir -p /mytools/maven 将maven.gz上传到该文件夹 解压 1tar -xvf apache-maven-3.9.4-bin.tar.gz 配置环境变量 1234vim /etc/profile export MAVEN_HOME=/mydata/maven/apache-maven-3.9.4 export PATH=$&#123;MAVEN_HOME&#125;/bin:$PATHsource /etc/profile 验证 1mvn -v 配置阿里镜像(看情况)","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|安装Docker","slug":"Server/docker","date":"2024-03-18T08:20:07.000Z","updated":"2024-03-18T08:26:17.374Z","comments":true,"path":"2024/03/18/Server/docker/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker/","excerpt":"","text":"环境 ： centos 8.4.2105 检查是否存在docker 1docker -v 卸载docker 12345678910yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 123yum remove docker-ce \\ docker-ce-cli \\ containerd 设置仓库 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 稳定仓库 12# 阿里云sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 1234# 清华镜像sudo yum-config-manager \\ --add-repo \\ https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 安装 Docker Engine-Community 1sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 问题： 原因：CentOS-8于2021年12月31日停止了源的服务 解决步骤： 1234567# 1cd /etc/yum.repos.d# 2mkdir bakcp * bak/# 3vi root_.repo #把enabled=1，改成enable=0 指定版本安装 123456789$ yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io 启动docker 123sudo systemctl start docker# 运行hello-world镜像，查看是否安装成功sudo docker run hello-world 卸载docker 1234# 删除安装包yum remove docker-ce# 删除镜像、容器、配置文件等内容rm -rf /var/lib/docker centos 8.2安装问题 设置仓库时发生问题： 解决：更新一下yum 1yum -y update 出现Failed to download metadata for repo ‘appstream’: Cannot prepare internal mirrorlist: No URLs in mirrorlist 问题原因： 因为centos8项目官方已于2021年底停止维护，相关源已无法使用，所以网上22年前的换源教程都已无法使用。 解决： 12345678#进入配置文件目录cd /etc/yum.repos.d/#删除旧的配置文件rm -rf *.repo# 下载可用的.repo文件wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo# 运行 yum makecache 生成缓存yum makecache","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|安装JDK","slug":"Server/JDK","date":"2024-03-18T08:14:07.000Z","updated":"2024-03-18T08:23:34.967Z","comments":true,"path":"2024/03/18/Server/JDK/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/JDK/","excerpt":"","text":"清华云下载jdk ： https://repo.huaweicloud.com/java/ 12345678910111213141516171819202122# 查看是否安装过jdkrpm -qa | grep java# ↑这里要是存在内容，执行删除rpm -qa | grep java | xargs rpm -e --nodeps# 查看java版本java -version# 创建存放java的文件mkdir /usr/java# cd进入这一个文件夹# 把下载好的jdk上传到这个文件夹下# 解压tar -xvf jdk1.8.0_202ar.gz# 配置环境vi /etc/profile# 在文件末尾添加 【注意=附近不要有空格】export JAVA_HOME=/usr/java/jdk1.8.0_202export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib/ export PATH=$PATH:$JAVA_HOME/bin# 初始化配置 - 执行这条语句，可以让环境立即生效，不需要重启source /etc/profile# 查看版本 (有信息的话，就安装成功了)java -version 如果上述中没有添加到环境中，尝试终端直接运行以下代码 1234export JAVA_HOME=/mytools/java/jdk1.8.0_202export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"Hexo|图片相关","slug":"Hexo/Hexo-图片相关","date":"2024-03-18T07:14:55.000Z","updated":"2024-03-18T07:55:33.857Z","comments":true,"path":"2024/03/18/Hexo/Hexo-图片相关/","permalink":"https://solitaire-12.github.io/2024/03/18/Hexo/Hexo-%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3/","excerpt":"","text":"1.相对路径挂载图片【文章显示】 在 _config.yml文件中配置 post_asset_folder 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 💬配置之后，当执行 hexo new titleName之后，会在该titleName.md文件夹的同级目录下生成一个同名文件夹用来存放图片资源。 .md文件中使用 1![](photoName.jpg) 💬hexo-renderer-marked默认渲染引擎，通过hexo g之后，会将该图片路径渲染成绝对路径。在文章列表中，无法加载图片。 2.绝对路径挂载图片【主页显示】 在source文件夹下，创建一个img文件夹用来存放图片 .md文件中使用 1![](/img/photoName.jpg) 💬/img代表根目录下的img文件夹，其中 /指代根目录【public文件夹】 3.同时显示 安装 hexo-asset-image 1npm hexo-asset-image --save 安装之后，发现图片路径都不显示了，F12查看图片路径变成了/.io//xxx.xx。 修复上述bug。进入到node_modules找到hexo-asset-image插件，用下述代码替换掉index.js原有代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&quot;use strict&quot;;var cheerio = require(&quot;cheerio&quot;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&quot;.&quot;);hexo.extend.filter.register(&quot;after_post_render&quot;, function (data) &#123; var config = hexo.config; if (config.post_asset_folder) &#123; var link = data.permalink; if (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &quot;/&quot;, 1) + 1; else var beginPos = getPosition(link, &quot;/&quot;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&quot;/&quot;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&quot;excerpt&quot;, &quot;more&quot;, &quot;content&quot;]; for (var i = 0; i &lt; toprocess.length; i++) &#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false, &#125;); $(&quot;img&quot;).each(function () &#123; if ($(this).attr(&quot;src&quot;)) &#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&quot;src&quot;).replace(&quot;\\\\&quot;, &quot;/&quot;); if (!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&quot;/&quot;).filter(function (elem) &#123; return elem != &quot;&quot;; &#125;); var srcArray = src.split(&quot;/&quot;).filter(function (elem) &#123; return elem != &quot;&quot; &amp;&amp; elem != &quot;.&quot;; &#125;); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&quot;/&quot;); $(this).attr(&quot;src&quot;, config.root + link + src); console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + config.root + link + src); &#125; &#125; else &#123; console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;); console.info &amp;&amp; console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 替换之后，重新hexo g即可。 4.支持emoji hexo-renderer-marked默认渲染引擎并不支持emoji，却换到可以支持的渲染引擎。笔者使用的是 hexo-renderer-markdown-it。 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save 在 _config.yml文件中配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243# hexo-renderer-markdown-itmarkdown: preset: &quot;default&quot; render: html: true xhtmlOut: false langPrefix: &quot;language-&quot; breaks: true linkify: true typographer: true quotes: &quot;“”‘’&quot; enable_rules: disable_rules: plugins: - markdown-it-abbr - markdown-it-cjk-breaks - markdown-it-deflist - markdown-it-emoji - markdown-it-footnote - markdown-it-ins - markdown-it-mark - markdown-it-sub - markdown-it-sup # - markdown-it-checkbox # - markdown-it-imsize # - markdown-it-expandable - name: markdown-it-container options: success - name: markdown-it-container options: tips - name: markdown-it-container options: warning - name: markdown-it-container options: danger anchors: level: 2 collisionSuffix: &quot;&quot; permalink: false permalinkClass: &quot;header-anchor&quot; permalinkSide: &quot;left&quot; permalinkSymbol: &quot;¶&quot; case: 0 separator: &quot;-&quot; 参考： Hexo图片相关 - 文章显示、主页显示、修改fancybox_hexo 文章缩略-CSDN博客 【Hexo】选择更高级的Markdown渲染器_hexo-renderer-marked-CSDN博客","categories":[{"name":"博客","slug":"博客","permalink":"https://solitaire-12.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://solitaire-12.github.io/tags/Hexo/"}]},{"title":"数据管理DMS","slug":"Server/dms","date":"2024-03-18T05:40:07.000Z","updated":"2024-03-18T09:12:06.386Z","comments":true,"path":"2024/03/18/Server/dms/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/dms/","excerpt":"","text":"下载：数据管理DMS–下载中心 (aliyun.com) 本地部署： 安装好之后，登录实例即可。 问题：内网IP链接失败 解决方法：【本地数据库是MySQL】 登录数据库，切换到mysql 1select user,host from user; # 查看信息 ⚠️上述信息是指该用户名只能通过localhost这个地址进行访问。 修改root用户的host 1update user set host =&quot;%&quot; where user = &quot;root&quot;; 刷新权限 1flush privileges;","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-03-14T05:00:15.235Z","updated":"2024-03-25T02:10:12.947Z","comments":true,"path":"2024/03/14/hello-world/","permalink":"https://solitaire-12.github.io/2024/03/14/hello-world/","excerpt":"","text":"$log_{}n$ $$ log_{}n $$ 😄 $$ \\frac{m}{2}\\leq k \\leq m $$ $log_{2}n$ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"初始","slug":"初始","permalink":"https://solitaire-12.github.io/categories/%E5%88%9D%E5%A7%8B/"}],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://solitaire-12.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://solitaire-12.github.io/categories/Java/"},{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"博客","slug":"博客","permalink":"https://solitaire-12.github.io/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"初始","slug":"初始","permalink":"https://solitaire-12.github.io/categories/%E5%88%9D%E5%A7%8B/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://solitaire-12.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java基础","slug":"Java基础","permalink":"https://solitaire-12.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"排序","slug":"排序","permalink":"https://solitaire-12.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"Java8","slug":"Java8","permalink":"https://solitaire-12.github.io/tags/Java8/"},{"name":"JVM","slug":"JVM","permalink":"https://solitaire-12.github.io/tags/JVM/"},{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"},{"name":"部署","slug":"部署","permalink":"https://solitaire-12.github.io/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://solitaire-12.github.io/tags/Hexo/"}]}
{"meta":{"title":"织秋个人博客","subtitle":"副标题","description":"座右铭","author":"solitaire-12","url":"https://solitaire-12.github.io","root":"/"},"pages":[{"title":"","date":"2024-03-14T09:19:27.963Z","updated":"2024-03-14T09:19:27.963Z","comments":true,"path":"404.html","permalink":"https://solitaire-12.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2024-03-19T04:54:36.000Z","updated":"2024-03-19T07:03:10.484Z","comments":true,"path":"about/index.html","permalink":"https://solitaire-12.github.io/about/index.html","excerpt":"","text":"2024-03-19 切换主题 Volantis 2024-03-18 同步笔记 服务器环境配置笔记JVMJava8 2024-03-15 切换主题 Async 2024-03-14 博客建立 简单说一下为啥建立这个博客吧。原先用gitee存放自己的笔记，每次写完之后push一下就好了，也算方便。随着笔记越来越多，想要在这种方式下找到自己想要的内容，简直噩梦。也尝试过Notion，不过Notion会把鸡蛋放一个篮子里。思来想去，搞了这个博客。","author":"织秋"},{"title":"友情链接","date":"2024-03-14T08:59:43.000Z","updated":"2024-03-14T09:00:13.560Z","comments":true,"path":"links/index.html","permalink":"https://solitaire-12.github.io/links/index.html","excerpt":"","text":""},{"title":"frineds","date":"2024-03-19T04:55:03.000Z","updated":"2024-03-19T04:55:03.563Z","comments":true,"path":"frineds/index.html","permalink":"https://solitaire-12.github.io/frineds/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-03-14T07:40:18.000Z","updated":"2024-03-14T08:58:24.939Z","comments":true,"path":"categories/index.html","permalink":"https://solitaire-12.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-03-14T08:59:06.000Z","updated":"2024-03-14T08:59:23.315Z","comments":true,"path":"tags/index.html","permalink":"https://solitaire-12.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法|排序","slug":"algorithm/sort","date":"2024-03-19T07:33:11.324Z","updated":"2024-03-19T08:13:17.393Z","comments":true,"path":"2024/03/19/algorithm/sort/","permalink":"https://solitaire-12.github.io/2024/03/19/algorithm/sort/","excerpt":"","text":"认识位运算符 获取整数的二进制32位字符 123456public static void print(int num) &#123; for (byte i = 31; i &gt;= 0; i--) &#123; System.out.print((num &amp; (1 &lt;&lt; i)) == 0 ? &quot;0&quot; : &quot;1&quot;); &#125; System.out.println();&#125; 结果： 123456789101112131415byte a = 43;byte b = 120;System.out.print(&quot;a :&quot;);print(a); //a :00101011System.out.print(&quot;b :&quot;);print(b); //b :01111000System.out.print(&quot;a|b:&quot;);print(a | b); //a|b:01111011System.out.print(&quot;a&amp;b:&quot;);print(a &amp; b); //a&amp;b:00101000System.out.print(&quot;a^b:&quot;);print(a ^ b); //a^b:01010011System.out.print(&quot; ~b:&quot;);print(~b); // ~b:10000111System.out.print(&quot;135:&quot;);print(135); //135:10000111System.out.print(&quot;a :&quot;);print(a); //a :00101011System.out.print(&quot;&lt;&lt;3:&quot;);print(a&lt;&lt;3); //&lt;&lt;3:01011000System.out.print(&quot;&gt;&gt;1:&quot;);print(a&gt;&gt;1); //&gt;&gt;1:00010101System.out.print(&quot;&gt;&gt;&gt;1:&quot;);print(a&gt;&gt;&gt;1); //&gt;&gt;&gt;1:00010101System.out.println(~b); //-121print(~b&gt;&gt;7); //11111111 |：或 1234//00101011//01111000//01111011print(43 | 120); //01111011 有1为1 &amp;：与 1234//00101011//01111000//00101000print(43 &amp; 120); //00101000 有0为0 ^：亦或 1234//00101011//01111000//01010011print(43 ^ 120); //01010011 无进位相加 ~：非 取反 1234//01111000//10000111print(~120); //10000111print(135); //10000111 ~120和135的字符是一样的，为什么它是-121不是135呢？ 首先理解，byte 占 8位（-128-127），其中[符号位]占一位，其余数据占用 其次当一个数是负数的时候，符号位以及其左边的位置，均为1。也就是说，-121是//1111....110000111，而135是//0000.....010000111 最后，~操作可以理解成在一条直线上，从[0和-1的中间位置]反方向去找到第n个点 注意：在程序中，0算正数。后文会验证这一结论。 &lt;&lt;：左移 12print(43); //00101011print(43&lt;&lt;3); //01011000 &gt;&gt;：右移 12print(43); //00101011print(43&gt;&gt;1); //00010101 &gt;&gt;&gt;：无符号右移 123print(43&gt;&gt;&gt;1); //00010101print(~120); //10000111print(~120&gt;&gt;7); //11111111 正数&gt;&gt;&gt; 等价 &gt;&gt; 常见使用 判断奇偶性 1(num &amp; 1) == 1 ? &quot;奇数&quot; : &quot;偶数&quot; 两个数做交换 123456789a = a ^ b;b = a ^ b;a = a ^ b;// 注意：在数组操作中时，切记不能进行用位置亦或，不然数据会丢失//可以简化成a ^= b;b ^= a;a ^= b; 取绝对值 12int b = -327int a = (b ^ (b&gt;&gt;31)) - (b&gt;&gt;31); 判断两个数是否异号 123456boolean f = ((x ^ y) &lt; 0);// 同号false，异号true// boolean f = ((0 ^ 1) &lt; 0);// System.out.println(f);// 结果是false 大小写转换 123456// (&#x27;A&#x27; | &#x27; &#x27;) = &#x27;a&#x27;// (&#x27;a&#x27; | &#x27; &#x27;) = &#x27;a&#x27;// (&#x27;A&#x27; &amp; &#x27;_&#x27;) = &#x27;A&#x27;// (&#x27;a&#x27; &amp; &#x27;_&#x27;) = &#x27;A&#x27;// (&#x27;A&#x27; ^ &#x27; &#x27;) = &#x27;a&#x27;// (&#x27;a&#x27; ^ &#x27; &#x27;) = &#x27;A&#x27; +1 12int n = 10;n = -~n; -1 12int n = 10;n = ~-n; 排序 排序动态展示（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序） - VisuAlgo 打印 1Arrays.stream(arr).forEach(a-&gt; System.out.print(a + &quot; &quot;)); 交换 12345public static void swap(int[] arr, int i, int j) &#123; int tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;&#125; 选择排序 12345678910111213public static void selectSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int N = arr.length; for (int i = 0; i &lt; N; i++) &#123; int minValueIndex = i; for (int j = i + 1; j &lt; N; j++) &#123; minValueIndex = arr[j] &lt; arr[minValueIndex] ? j : minValueIndex; &#125; swap(arr, i, minValueIndex); &#125;&#125; 冒泡排序 12345678910111213public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int N = arr.length; for (int end = N - 1; end &gt;= 0; end--) &#123; for (int second = 1; second &lt;= end; second++) &#123; if (arr[second - 1] &gt; arr[second]) &#123; swap(arr, second - 1, second); &#125; &#125; &#125;&#125; 插入排序 12345678910111213141516171819202122232425public static void insertSort1(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int N = arr.length; for (int end = 1; end &lt; N; end++) &#123; int newNumIndex = end; while (newNumIndex - 1 &gt;= 0 &amp;&amp; arr[newNumIndex - 1] &gt; arr[newNumIndex]) &#123; swap(arr, newNumIndex - 1, newNumIndex); newNumIndex--; &#125; &#125;&#125;public static void insertSort2(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int N = arr.length; for (int end = 1; end &lt; N; end++) &#123; for (int pre = end - 1; pre &gt;= 0 &amp;&amp; arr[pre] &gt; arr[pre + 1]; pre--) &#123; swap(arr, pre, pre + 1); &#125; &#125;&#125; 归并排序 123456789101112131415161718192021222324252627282930public static void mergeSort(int[] arr, int left, int right) &#123; if (left == right) return; //分成两半 int mid = left + (right-left)/2; //左边排序 mergeSort(arr, left, mid); //右边排序 mergeSort(arr, mid+1, right); merge(arr, left, mid+1, right);&#125;static void merge(int[] arr, int leftPtr, int rightPtr, int rightBound) &#123; int mid = rightPtr - 1; int[] temp = new int[rightBound - leftPtr + 1]; int i = leftPtr; int j = rightPtr; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= rightBound) &#123; temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++]; &#125; while(i&lt;=mid) temp[k++] = arr[i++]; while(j&lt;=rightBound) temp[k++] = arr[j++]; for(int m=0; m&lt;temp.length; m++) arr[leftPtr +m] = temp[m];&#125; 快速排序 123456789101112131415161718192021222324public static void quickSort(int[] arr, int leftBound, int rightBound) &#123; if(leftBound &gt;= rightBound) return; int mid = partition(arr, leftBound, rightBound); quickSort(arr, leftBound, mid-1); quickSort(arr, mid+1, rightBound);&#125;static int partition(int[] arr, int leftBound, int rightBound) &#123; //adding the following code blocks is the random quick sort &#123; int random = leftBound + (int) (Math.random() * (rightBound - leftBound + 1)); swap(arr, random, rightBound); &#125; int pivot = arr[rightBound]; int left = leftBound; int right = rightBound - 1; while(left &lt;= right) &#123; while(left &lt;= right &amp;&amp; arr[left] &lt;= pivot) left ++; while(left &lt;= right &amp;&amp; arr[right] &gt; pivot) right --; if(left &lt; right) BaseCoding.swap(arr, left, right); &#125; BaseCoding.swap(arr, left, rightBound); return left;&#125; 计数排序 12345678910111213141516171819202122232425/** * 计数排序： * 遍历源数组找到最大值，通过这最大值创建一个计数数组； * 遍历源数组，在计数数组，源数组值位置，++； * 遍历计数数组，将数值大于0位置，以此写入源数组。 * * @param arr 原数组 */public static void countSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); &#125; int[] bucket = new int[max + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; bucket[arr[i]]++; &#125; int i = 0; for (int j = 0; j &lt; bucket.length; j++) &#123; while (bucket[j]-- &gt; 0) &#123; arr[i++] = j; &#125; &#125;&#125; 堆排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 堆排序: * * @param arr 源数组 */public static void heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; // O(N*logN) // for (int i = 0; i &lt; arr.length; i++) &#123; // heapInsert(arr, i); // &#125; // O(N) for (int i = arr.length - 1; i &gt;= 0; i--) &#123; heapify(arr, i, arr.length); &#125; int heapSize = arr.length; swap(arr, 0, --heapSize); // O(N*logN) while (heapSize &gt; 0) &#123; heapify(arr, 0, heapSize); swap(arr, 0, --heapSize); &#125;&#125;private static void heapify(int[] arr, int index, int heapSize) &#123; int left = (index &lt;&lt; 1) + 1; while (left &lt; heapSize) &#123; // 下方还有孩子的时候 // 两个孩子中，谁的值大，把下标给largest // 1）只有左孩子，left -&gt; largest // 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest // 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; // 父和较大的孩子之间，谁的值大，把下标给largest largest = arr[largest] &gt; arr[index] ? largest : index; if (largest == index) &#123; break; &#125; swap(arr, largest, index); index = largest; left = (index &lt;&lt; 1) + 1; &#125;&#125;private static void heapInsert(int[] arr, int index) &#123; while (arr[index] &gt; arr[(index - 1) / 2]) &#123; swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; &#125;&#125; 基数排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 基数排序 * @param arr */public static void radixSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; radixSort(arr, 0, arr.length - 1, maxbits(arr));&#125;private static int maxbits(int[] arr) &#123; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); &#125; int res = 0; while (max != 0) &#123; res++; max /= 10; &#125; return res;&#125;private static void radixSort(int[] arr, int L, int R, int digit) &#123; final int radix = 10; int i = 0, j = 0; int[] help = new int[R - L + 1]; for (int d = 1; d &lt;= digit; d++) &#123; int[] count = new int[radix]; // count[0..9] for (i = L; i &lt;= R; i++) &#123; j = getDigit(arr[i], d); count[j]++; &#125; for (i = 1; i &lt; radix; i++) &#123; count[i] = count[i] + count[i - 1]; &#125; for (i = R; i &gt;= L; i--) &#123; j = getDigit(arr[i], d); help[count[j] - 1] = arr[i]; count[j]--; &#125; for (i = L, j = 0; i &lt;= R; i++, j++) &#123; arr[i] = help[j]; &#125; &#125;&#125;public static int getDigit(int x, int d) &#123; return ((x / ((int) Math.pow(10, d - 1))) % 10);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://solitaire-12.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://solitaire-12.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":"织秋"},{"title":"Java|Java8","slug":"Java/Java8","date":"2024-03-18T12:14:55.000Z","updated":"2024-03-19T00:38:25.379Z","comments":true,"path":"2024/03/18/Java/Java8/","permalink":"https://solitaire-12.github.io/2024/03/18/Java/Java8/","excerpt":"","text":"java8实战汇总 Lambda表达式 Lambda表达式有三个部分，参数-&gt;主体 12(parameters) -&gt; expression(parameters) -&gt;&#123; statements; &#125; 123456789() -&gt; &#123;&#125; () -&gt; &quot;Raoul&quot;() -&gt; &#123;return &quot;Mario&quot;; &#125;// return是一个控制流语句。要使用此Lambda有效，需要使用花括号(Integer i) -&gt; return &quot;Alan&quot; + i; (Integer i) -&gt; &#123;return &quot;Alan&quot; + i;&#125;// “Iron Man”是一个表达式，不是一个语句。要使此Lambda有效，可以去除花括号和分号(String s) -&gt; &#123;&quot;Iron Man&quot;; &#125; (String s) -&gt; &quot;Iron Man&quot;; 演示代码 1 stream流的操作 ❏ 元素序列——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList与LinkedList）。但流的目的在于表达计算，比如你前面见到的filter、sorted和map。集合讲的是数据，流讲的是计算。后面几节会详细解释这个思想。 ❏ 源——流会使用一个提供数据的源，比如集合、数组或I/O资源。请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。 ❏ 数据处理操作——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，比如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可以并行执行。 流操作有两个重要的特点。 ❏ 流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，构成一个更大的流水线。这使得一些优化成为可能，比如处理延迟和短路。流水线的操作可以看作类似对数据源进行数据库查询。 ❏ 内部迭代——与集合使用迭代器进行显式迭代不同，流的迭代操作是在后台进行的。 示例代码 12345678910List&lt;Dish&gt; menu = Arrays.asList( new Dish(&quot;pork&quot;, false, 800, Dish.Type.MEAT), new Dish(&quot;beef&quot;, false, 700, Dish.Type.MEAT), new Dish(&quot;chicken&quot;, false, 400, Dish.Type.MEAT), new Dish(&quot;french fries&quot;, true, 530, Dish.Type.OTHER), new Dish(&quot;rice&quot;, true, 350, Dish.Type.OTHER), new Dish(&quot;season fruit&quot;, true, 120, Dish.Type.OTHER), new Dish(&quot;pizza&quot;, true, 550, Dish.Type.OTHER), new Dish(&quot;prawns&quot;, false, 300, Dish.Type.FISH), new Dish(&quot;salmon&quot;, false, 450, Dish.Type.FISH) ); 1234567891011121314151617181920212223242526272829public class Dish &#123; private final String name; private final boolean vegetarian; private final int calories; private final Type type; public Dish(String name, boolean vegetarian, int calories, Type type) &#123; this.name = name; this.vegetarian = vegetarian; this.calories = calories; this.type = type; &#125; public String getName() &#123; return name; &#125; public boolean isVegetarian() &#123; return vegetarian; &#125; public int getCalories() &#123; return calories; &#125; public Type getType() &#123; return type; &#125; @Override public String toString() &#123; return name; &#125; public enum Type &#123; MEAT, FISH, OTHER &#125;&#125; 初次使用stream 1234567// toList()是一个静态方法，需要 import static java.util.stream.Collectors.toList;// 要是不想导包，可以把toList() 改成 Collectors.toList()List&lt;String&gt; collect = menu.stream().filter(dish -&gt; dish.getCalories() &gt; 300) .map(Dish::getName) .limit(3) .collect(toList());System.out.println(collect); 上述中Dish::getName相当于Lambda d -&gt; d.getName() 筛选（filter）、提取（map）或截断（limit）功能 流的特性 只能遍历一遍 123Stream&lt;Dish&gt; stream = menu.stream();stream.forEach(System.out::println);stream.forEach(System.out::println); 内部迭代 1234567891011121314151617// 用for-each循环外部迭代ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();for (Dish dish : menu) &#123; names.add(dish.getName());&#125;/** * for-each结构是一个语法糖，其背后逻辑是一个迭代器，Iterator */ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();Iterator&lt;Dish&gt; iterator = menu.iterator();while (iterator.hasNext())&#123; names.add(iterator.next().getName());&#125;// stream的内部迭代List&lt;String&gt; names = menu.stream().map(Dish::getName).collect(toList());System.out.println(names); 重构测试 12345678List&lt;String&gt; highCaloricDishes = new ArrayList&lt;&gt;();Iterator&lt;String&gt; iterator = menu.iterator();while(iterator.hasNext()) &#123; Dish dish = iterator.next(); if(dish.getCalories() &gt; 300) &#123; highCaloricDishes.add(d.getName()); &#125;&#125; 1234List&lt;String&gt; highCaloricDishes = menu.stream() .filter(dish -&gt; dish.getCalories() &gt; 300) .collect(toList()); 流的操作 从上述代码中,不难看出，stream()之后跟着filter，map，limit，collect等操作，这是java.util.stream.Stream中的Stream接口定义的操作，它们可以分成两类。 ❏ 中间操作：filter、map和limit可以连成一条流水线； ❏终端操作： collect触发流水线执行并关闭它。 总结： 一个数据源 一个中间操作链，形成流水线 一个终端操作，执行流水线，并生成结果 中间操作 类型 操作 返回类型 操作参数 函数描述 作用 filter Stream&lt;T&gt; Predicate&lt;T&gt; T -&gt; boolean 筛选 map Stream&lt;R&gt; Function&lt;T,R&gt; T -&gt; R 获取 有状态-无界 limit Stream&lt;T&gt; 截选 有状态-无界 skip Stream&lt;T&gt; 跳过 有状态-无界 sorted Stream&lt;T&gt; Comparator&lt;T&gt; (T,T) -&gt; int 有状态-无界 distinct Stream&lt;T&gt; 去重 终端操作 类型 操作 返回类型 作用 forEach void 消费流中的每个元素并对其应用Lambda count long 返回流中元素的个数 collect (generic) 把流整合成一个集合，比如List，Map，甚至是Iterator anyMatch boolean noneMatch boolean allMatch boolean findAny Optinal&lt;T&gt; findFirst Optinal&lt;T&gt; 有状态-有界 reduce Optinal&lt;T&gt; 使用流 筛选 谓词筛选 12List&lt;Dish&gt; collect = menu.stream().filter(Dish::isVegetarian).collect(toList());System.out.println(collect); 筛选各异的元素 流还支持一个叫作distinct的方法，它会返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。例如，以下代码会筛选出列表中所有的偶数，并确保没有重复（使用equals方法进行比较) 12345List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);numbers.stream() .filter(i -&gt; i % 2 == 0) .distinct() .forEach(System.out::println); 切片 谓词切片 takeWhile和dropWhile，这两个是java9引入的新方法。 引入原因：倘若数据源已经按照热量从小到大排序了，还要筛选出热量小于320的数据，filter筛选会去遍历所有数据，这样比较消耗性能。所以引入了takeWhile和dropWhile。 takeWhile:通过谓词去选取出符合的数据，遭遇到第一个不符合的元素时，停止处理 dropWhile:和taskWhile是相反的操作，它会删除掉符合要求的数据 截短流 流支持limit(n)方法，该方法会返回另一个不超过给定长度的流。所需的长度作为参数传递给limit。如果流是有序的，则最多会返回前n个元素。 跳过元素 流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。请注意，limit(n)和skip(n)是互补的 映射 流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”） 流的扁平化 案例 对于一张单词表，如何返回一张列表，列出里面各不相同的字符? 例如，给定单词列表[“Hello”,“World”]，要返回列表[“H”, “e”, “l”, “o”, “W”, “r”, “d”] 尝试1：不行 1234567List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;);List&lt;String[]&gt; collect = words.stream() .map(word -&gt; word.split(&quot;&quot;)) .distinct() .collect(toList());System.out.println(&quot;words = &quot; + words); 尝试2：不行 12345678List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;);List&lt;Stream&lt;String&gt;&gt; collect = words.stream() .map(word -&gt; word.split(&quot;&quot;)) .map(Arrays::stream) .distinct() .collect(toList());System.out.println(&quot;words = &quot; + words); 解释Arrays::stream： 1234String[] arrayOfWords = &#123;&quot;Goodbye&quot;, &quot;World&quot;&#125;;List&lt;String&gt; streamOfwords = Arrays .stream(arrayOfWords) // 这是Stream&lt;String&gt;类型的 .collect(toList()); 尝试3：使用flatMap,成功 flatMap 12345678List&lt;String&gt; words = Arrays.asList(&quot;hello&quot;, &quot;world&quot;);List&lt;String&gt; collect = words.stream() .map(word -&gt; word.split(&quot;&quot;)) .flatMap(Arrays::stream) .distinct() .collect(toList());System.out.println(&quot;words = &quot; + words); 查找和匹配 另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream API通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的工具。 anyMatch anyMatch方法可以回答“流中是否有一个元素能匹配给定的谓词” 比如↓，你可以用它来看看菜单里面是否有素食可选择 1234if(menu.stream().anyMatch(Dish::isVegetarian))&#123; System.out.println(&quot;The menu is (somewhat) vegetarian friendly! ! &quot;);&#125;//anyMatch方法返回一个boolean allMatch allMatch方法会看流中的元素是否都能匹配给定的谓词。 比如↓，你可以用它来看看菜品是否有利健康（即所有菜的热量都低于1000卡路里）： 1boolean isHealthy = menu.stream().allMatch(dish -&gt; dish.getCalories() &lt; 1000); noneMatch 它可以确保流中没有任何元素与给定的谓词匹配 比如↓，你可以用noneMatch重写前面的例子 1boolean isHealthy = menu.stream().noneMatch(dish -&gt; dish.getCalories() &gt;= 1000); findAny findAny方法将返回当前流中的任意元素。它可以与其他流操作结合使用 比如↓，你可能想找到一道素食菜肴。可以结合使用filter和findAny方法来实现这个查询 Optional 1Optional&lt;Dish&gt; dish = menu.stream().filter(Dish::isVegetarian).findAny(); findFirst 有些流由一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。对于这种流，你可能想要找到第一个元素。为此有一个findFirst方法，它的工作方式类似于findAny 123456List&lt;Integer&gt; someNumbers = Arrays.asList(1, 2, 3, 4, 5);Optional&lt;Integer&gt; firstSquareDivisibleByThree = someNumbers.stream() .map(n -&gt; n * n) .filter(n -&gt; n % 3 == 0) .findFirst(); // 9 归约-reduce 此类查询需要将流中所有元素反复结合起来，得到一个值，比如一个Integer。这样的查询可以被归类为归约操作（将流归约成一个值）。用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果 求和 在研究如何使用reduce方法之前，先来看看如何使用for-each循环来对数字列表中的元素求和 1234int sum = 0;for (int x : numbers) &#123; sum += x;&#125; 从上述代码看，for-each的求和过程并不复杂，那为什么还要引入reduce呢？ for-each代码复用率低，reduce对重复应用的模式做了抽象 12// 引入reduce求和int sum = numbers.stream().reduce(0,(a,b)-&gt;a+b); reduce接收的参数： 初始值，即对应for-each中的sum BinaryOperator&lt;T&gt;用来将两个元素结合起来产生一个新的值。上述代码中是一个lambda表达式 (a,b)-&gt;a+b 所以，当有累乘的业务时，我们可也写成： 1int product = numbers.stream().reduce(1,(a,b)-&gt;a*b); 引入java8静态方法sum进行求和 1int sum = numbers.stream().reduce(0,Integer::sum); 无初始值 reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象 1int sum = numbers.stream().reduce((a,b)-&gt;a+b); 最大值和最小值 12Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min); 归约方法的优势与并行化 从for-each循环求和来看，这种迭代求和方式一旦并行，问题时致命的。而reduce提供了更加安全，简便的实现方式。 123// use stream to sum all elements in parallel// 使用流对所有元素并行求和int sum = numbers.parallelStream().reduce(0,Integer::sum); 原始类型流特化 1int calories = menu.stream().map(Dish::getCalories).reduce(0, Integer::sum); 像上述代码，直接写成int calories = menu.stream().map(Dish::getCalories).sum();不是更好？但这却是不可能的，因为map方法生成的是Stream&lt;T&gt;类型的数据，没办法通过sum()方法来实现求和，不过Stream API提供了原始类型流特化，专门处理数值流的方法 IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本 映射到数值流 将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong 这些方法和前面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream IntStream还支持其他的方便方法，如max、min、average等 1234int sum = menu.stream() //Stream&lt;Dish&gt; .mapToInt(Dish::getCalories) // IntStream .sum(); // 如果IntStream是空的话，返回的是0 转换回对象流 同样，一旦有了数值流，你可能会想把它转换回非特化流。例如，IntStream上的操作只能产生原始整数：IntStream的map操作接受的Lambda必须接受int并返回int（一个IntUnaryOperator）。但是你可能想要生成另一类值，比如Dish 123IntStream intStream = menu.stream() .mapToInt(Dish::getCalories);Stream&lt;Integer&gt; stream = intStream.boxed(); 默认值OptionalInt 求和的那个例子很容易，因为它有一个默认值：0。但是，如果你要计算IntStream中的最大元素，就得换个法子了，因为0是错误的结果 Optional类，这是一个可以表示值存在或不存在的容器。Optional可以用Integer、String等参考类型来参数化。对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt、OptionalDouble和OptionalLong 123456OptionalInt maxCalories = menu.stream() .mapToInt(Dish::getCalories) .max();System.out.println(&quot;maxCalories = &quot; + maxCalories);int max = maxCalories.orElse(1); 数值范围 123456789IntStream.range(1, 10) .filter(value -&gt; value % 2 == 0) .forEach(System.out::println); // ↑结果：2，4，6，8IntStream.rangeClosed(1, 10) .filter(value -&gt; value % 2 == 0) .forEach(System.out::println); // ↑结果：2，4，6，8，10 // 总结range范围[x,y),rangeClosed范围[x,y] 尝试：获取勾股数 123456789101112131415161718192021Stream&lt;int[]&gt; pythagoreanTriples = IntStream.rangeClosed(1, 100).boxed() .flatMap(a -&gt; IntStream.rangeClosed(a, 100) .filter(b -&gt; Math.sqrt(a*a + b*b) % 1 == 0) .mapToObj( b -&gt; new int[]&#123;a, b, (int)Math.sqrt(a * a + b * b)&#125;) );pythagoreanTriples.limit(5).forEach(t-&gt;System.out.println(t[0]+&quot;,&quot;+ t[1] + &quot;,&quot; + t[2]));Stream&lt;double[]&gt; pythagoreanTriples = IntStream.rangeClosed(1, 100).boxed() .flatMap(a -&gt; IntStream.rangeClosed(a, 100) .mapToObj( b -&gt; new double[]&#123;a, b, Math.sqrt(a * a + b * b)&#125;) ) .filter(t -&gt; t[2] % 1 == 0);pythagoreanTriples.limit(5).forEach(t-&gt;System.out.println(t[0]+&quot;,&quot;+ t[1] + &quot;,&quot; + t[2])); Optional简介 Optional&lt;T&gt;类（java.util.Optional）是一个容器类，代表一个值存在或不存在。 在上述代码中，findAny存在什么元素都没有找到的可能，所以java8引入了Optional&lt;T&gt;,用来避免返回null的问题 测试 测试1：filter 根据示例代码，结合filter使用流筛选出前两个荤菜 12345List&lt;Dish&gt; collect = menu.stream() .filter(dish -&gt; dish.getType().equals(Dish.Type.MEAT)) .limit(2) .collect(toList()); 测试2：map 根据示例代码，结合映射 (1)给定一个数字列表，如何返回一个由每个数的平方构成的列表呢？例如，给定[1, 2, 3, 4, 5]，应该返回[1, 4, 9, 16,25]。 (2) 给定两个数字列表，如何返回所有的数对呢？例如，给定列表[1, 2, 3]和列表[3, 4]，应该返回[(1, 3), (1, 4), (2, 3), (2,4), (3, 3), (3, 4)]。为简单起见，你可以用有两个元素的数组来代表数对 (3) 如何扩展前一个例子，只返回总和能被3整除的数对 12345// (1)给定一个数字列表，如何返回一个由每个数的平方构成的列表呢？例如，给定[1, 2, 3, 4, 5]，应该返回[1, 4, 9, 16,25]。List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);List&lt;Integer&gt; collect = numbers.stream().map(n -&gt; n * n) .collect(toList());System.out.println(&quot;collect = &quot; + collect); 123456789// (2)给定两个数字列表，如何返回所有的数对呢？例如，给定列表[1, 2, 3]和列表[3, 4]，应该返回[(1, 3), (1, 4), (2, 3), (2,4), (3, 3), (3, 4)]。为简单起见，你可以用有两个元素的数组来代表数对List&lt;Integer&gt; numbers1 = Arrays.asList(1, 2, 3);List&lt;Integer&gt; numbers2 = Arrays.asList(3, 4);List&lt;int[]&gt; pairs = numbers1.stream() .flatMap(i -&gt; numbers2.stream() .map(j -&gt; new int[]&#123;i, j&#125;) ) .collect(toList()); 1234567891011// (3)如何扩展前一个例子，只返回总和能被3整除的数对List&lt;Integer&gt; numbers1 = Arrays.asList(1, 2, 3);List&lt;Integer&gt; numbers2 = Arrays.asList(3, 4);List&lt;int[]&gt; pairs = numbers1.stream() .flatMap(i -&gt; numbers2.stream() .filter(j -&gt; (i + j) % 3 == 0) .map(j -&gt; new int[]&#123;i, j&#125;) ) .collect(toList()); 测试3：reduce 根据示例代码，结合reduce，数一数流中有多少个菜 1int count = menu.stream().map(d -&gt; 1).reduce(0, (a, b) -&gt; a + b); 等价于 1long count = menu.stream().count(); 综合测试 源代码 123456789101112Trader raoul = new Trader(&quot;Raoul&quot;, &quot;Cambridge&quot;);Trader mario = new Trader(&quot;Mario&quot;, &quot;Milan&quot;);Trader alan = new Trader(&quot;Alan&quot;, &quot;Cambridge&quot;);Trader brian = new Trader(&quot;Brian&quot;, &quot;Cambridge&quot;);List&lt;Transaction&gt; transactions = Arrays.asList( new Transaction(brian, 2011, 300), new Transaction(raoul, 2012, 1000), new Transaction(raoul, 2011, 400), new Transaction(mario, 2012, 710), new Transaction(mario, 2012, 700), new Transaction(alan, 2012, 950)); 1234567891011121314151617181920212223242526272829303132333435363738394041public class Trader&#123; private final String name; private final String city; public Trader(String n, String c)&#123; this.name = n; this.city = c; &#125; public String getName()&#123; return this.name; &#125; public String getCity()&#123; return this.city; &#125; public String toString()&#123; return &quot;Trader:&quot;+this.name + &quot; in &quot; + this.city; &#125;&#125;public class Transaction&#123; private final Trader trader; private final int year; private final int value; public Transaction(Trader trader, int year, int value)&#123; this.trader = trader; this.year = year; this.value = value; &#125; public Trader getTrader()&#123; return this.trader; &#125; public int getYear()&#123; return this.year; &#125; public int getValue()&#123; return this.value; &#125; public String toString()&#123; return &quot;&#123;&quot; + this.trader + &quot;, &quot; + &quot;year: &quot;+this.year+&quot;, &quot; + &quot;value:&quot; + this.value +&quot;&#125;&quot;; &#125;&#125; 问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// (1) 找出2011年发生的所有交易，并按交易额排序（从低到高）。 List&lt;Transaction&gt; tr2011 = transactions.stream() .filter(transaction -&gt; transaction.getYear() == 2011) .sorted(Comparator.comparing(Transaction::getValue)) .collect(Collectors.toList()); System.out.println(&quot;tr2011 = &quot; + tr2011);// (2) 交易员都在哪些不同的城市工作过？ List&lt;String&gt; cities = transactions.stream() .map(transaction -&gt; transaction.getTrader().getCity()) .distinct() .collect(Collectors.toList());// Set&lt;String&gt; cities = transactions.stream()// .map(transaction -&gt; transaction.getTrader().getCity())// .collect(Collectors.toSet());// System.out.println(&quot;cities = &quot; + cities); System.out.println(&quot;cities = &quot; + cities);// (3) 查找所有来自于剑桥的交易员，并按姓名排序。 List&lt;Trader&gt; cambridgeTrader = transactions.stream() .map(Transaction::getTrader) .filter(trader -&gt; trader.getCity().equals(&quot;Cambridge&quot;)) .distinct() .sorted(Comparator.comparing(Trader::getName)) .collect(Collectors.toList()); System.out.println(&quot;cambridgeTrader = &quot; + cambridgeTrader);// (4) 返回所有交易员的姓名字符串，按字母顺序排序。// String reduce = transactions.stream()// .map(transaction -&gt; transaction.getTrader().getName())// .distinct()// .sorted()// .reduce(&quot;&quot;, (n1, n2) -&gt; n1 + n2); String reduce = transactions.stream() .map(transaction -&gt; transaction.getTrader().getName()) .distinct() .sorted() .collect(Collectors.joining()); System.out.println(&quot;reduce = &quot; + reduce);// (5) 有没有交易员是在米兰工作的？ boolean anyOneInMilan = transactions.stream() .anyMatch(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Milan&quot;)); System.out.println(&quot;anyOneInMilan = &quot; + anyOneInMilan);// (6) 打印生活在剑桥的交易员的所有交易额。 transactions.stream() .filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;)) .map(Transaction::getValue) .forEach(System.out::println);// (7) 所有交易中，最高的交易额是多少？ Optional&lt;Integer&gt; max = transactions.stream() .map(Transaction::getValue) .reduce(Integer::max); Optional&lt;Transaction&gt; max1 = transactions.stream().max(Comparator.comparing(Transaction::getValue)); System.out.println(&quot;max = &quot; + max); System.out.println(&quot;max1 = &quot; + max1);// (8) 找到交易额最小的交易。 Optional&lt;Integer&gt; min = transactions.stream() .map(Transaction::getValue) .reduce(Integer::min); Optional&lt;Transaction&gt; min1 = transactions.stream().min(Comparator.comparing(Transaction::getValue)); System.out.println(&quot;min = &quot; + min); System.out.println(&quot;min1 = &quot; + min1); 测试树形数据 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) &#123; ArrayList&lt;Zz&gt; source = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 10; i++) &#123; Zz z1 = new Zz(); z1.setId(Long.valueOf(i)); int i1 = i % 3 == 2 ? i - 1 : 0; z1.setPid(Long.valueOf(i1)); source.add(z1); &#125; System.out.println(source); List&lt;Zz&gt; tree = source.stream() .filter(item -&gt; item.getPid().equals(0)) .map(item -&gt; &#123; List&lt;Zz&gt; children = new ArrayList&lt;&gt;(); item.setChildren(children); getChildren(children, item.getId(), source); return item; &#125;) .collect(Collectors.toList()); System.out.println(tree);&#125;private static void getChildren(List&lt;Zz&gt; children, Long id, ArrayList&lt;Zz&gt; source) &#123; source.stream() .filter(item -&gt; item.getPid().equals(id)) .map(item -&gt; &#123; children.add(item); List&lt;Zz&gt; child = new ArrayList&lt;&gt;(); item.setChildren(child); getChildren(children, item.getId(), source); return item; &#125;) .collect(Collectors.toList());&#125; 函数式编程Function 待续","categories":[{"name":"Java","slug":"Java","permalink":"https://solitaire-12.github.io/categories/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://solitaire-12.github.io/tags/Java8/"}]},{"title":"Java|JVM","slug":"Java/JVM","date":"2024-03-18T12:10:55.000Z","updated":"2024-03-19T00:38:37.182Z","comments":true,"path":"2024/03/18/Java/JVM/","permalink":"https://solitaire-12.github.io/2024/03/18/Java/JVM/","excerpt":"","text":"类加载 加载过程 将java文件编译成class字节码文件，通过类加载器写入到JVM虚拟机运行时数据区中。 类加载流程 ​ 类加载需要经历五个阶段，分别是加载，验证，准备，解析，初始化。其中加载，验证，准备，初始化这四个阶段发生的顺序时确定的，而解析阶段时不一定的。它在某些情况下可以在初始化阶段之后开始，这是为了支持java的运行时绑定（也称做动态绑定）。另外，这些阶段都是按顺序开始，而非按顺序进行或者完成。 类加载器 双亲委派机制： ​ 当某个类加载器需要加载某个class文件时，它首先会把这个任务委派给它的父级加载器，递归到顶级加载器。随后进行加载，倘若加载失败，由子类加载器进行加载。可以保证同一个class只被加载一次。 运行时数据区 绿色线程共享，蓝色线程私有 JDK6：有永久代，静态变量存放在永久代上 JDK7：有永久代，但是已经把运行时常量池，常量池存放在方法区中了，逐渐的减少永久代的使用。 JDK8：无永久代，运行是常量池、类常量池都保存在元数据区，也就是元空间 。但是字符串常量池任然放在堆上。需要注意的是：元空间占用的是本地内存。 内存模型 程序计数器 线程私有。Java虚拟机执行多线程时，由于CPU时间片限制，线程执行具有随机性，操作系统会一直切换执行不同指令，我们需要把切换时候线程执行的位置存入到PC寄存器中，等切回来的时候能够回到原来的位置继续执行。 任何时候，每个Java虚拟机都在执行单个方法的代码，即该线程的当前方法。如果该方法不是Native方法，即PC寄存器会记录当前正在执行的java虚拟机指令的地址，如果线程当前执行的方法是本地的，那么java虚拟机的PC寄存器的值就是Undefined。 程序计数器是唯一一个不会出现OOM的区域。 本地方法栈 线程私有。提供虚拟机使用到本地Native方法，本地方法栈和虚拟机栈在有的虚拟机是合在一起的，例如Hot Spot虚拟机。 栈 线程私有，每个线程都有一个与线程同时创建的私有的虚拟机栈。虚拟机栈中存储栈帧，每个被线程调用的方法都会产生一个栈帧，栈帧中保存一个方法的状态信息，例如局部变量(存储方法内的局部变量)、操作数帧(用来计算临时存放变量)、方法出口(记录哪个方法的本方法)、动态链接(存放方法的元信息)等。调用一个方法就是执行一个栈帧的过程，一个方法调用完成，对应的栈帧就会出栈。 如果线程执行所需栈深度大于Java虚拟机栈深度，就会抛出StackOverFlowError，其实方法调用的过程就是入栈和出栈的过程，如果一致入栈不出栈，就容易发生异常（递归调用） 如果Java虚拟机栈可以动态扩展，但是扩展大小的时候无法申请到足够的内存，则会抛出OutOfMemoryError。 堆 线程共享。堆是java虚拟机管理内存最大的一块，在虚拟机启动时创建，所有线程共享，堆中的对象永远不会被显式释放，必须由GC回收，所以GC也主要回收堆中的对象实例，我们平常讨论的垃圾回收就是回收堆内存。堆可以处于物理上不连续的空间，可以固定大小，也可以动态扩展，通过参数-Xms和-Xmx两个参数控制堆的最小值和最大值。这里是**OOM异常的易发区** 分成新生代和老年代。 新生代又分成1个Eden区和2个Survivor区，默认比例8:1:1 绝大多数对象在Eden区生成，**当Eden区填满，或者不满足新建一个对象时，触发Young GC。**将存活的对象放进Survivor。Survivor分成两块，用于每次Young GC时，将存活的对象统统复制进空的幸存区，将有数据的那块清空。 当一个对象在两个survivor区之间交换了一定次数之后，将对象拷贝到老年代。这个数量用-XX:MaxTenuringThreshold配置，默认值是15 方法区 线程共享，在虚拟机启动时创建，存储已经被虚拟机加载的类信息、常量、静态变量，即经编译器之后的数据(运行时常量池[存放class文件元信息描述，编译后的代码数据，引用类型数据，类文件常量池]、属性和方法数据)，以及方法和构造函数的代码，包括在类和实例初始化以及接口初始化使用的特殊方法，方法区在逻辑上是堆的一部分，但是它又有另一个别名叫非堆，目的是与堆区分开。方法区可以是固定大小，也可以根据计算需要进行扩展。如果方法区的内存无法满足分配请求时也会抛出OutOfMemoryError。 永久代 元空间 JDK8使用元空间代替永久代（类元信息，字段，静态属性，方法，常量），同时运行时常量池等都移动到了元空间，字符串常量池在堆中。 元空间在本地内存中，它独立于运行时数据区，也不是Java虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受堆大小影响。但是会受到本机总内存大小以及处理器寻址空间的限制，因此它也可能抛出OOM异常。 垃圾回收 找到垃圾 ​ 两种方法判断对象是否需要销毁： 引用计数法 ​ 为对象添加一个引用计数器，每当对象被引用，引用计数器加1。当引用失效，减一。计数器为零，代表该对象可以被回收。 ​ **问题：**循环引用问题 可达性分析 ​ 通过一系列&quot;GC Roots&quot;的根节点开始，沿用引用链进行搜索，凡是在引用链上的，都不会被回收。 ​ 解决了循环依赖问题。 垃圾回收算法-GC 标记-清除算法 首先在堆内存扫描一遍，然后把灰色区域的对象标记 继续扫描，扫描的同时将被标记的对象统一回收回收后： 回收之后，产生大量不连续的内存碎片。 需要进行标记，清除两个过程，效率不高。 复制算法 ​ 将内存区域分成大小一样的两块，每次只是用一块，gc之后将对象复制到另一块，然后一次性清理掉这块内存。 回收前： 回收后： 复制算法的缺点是牺牲了一半的内存空间，有点浪费。复制算法在JVM中的体现就是：java堆内存做了几次划分，Hot Spot虚拟机中Eden和Survivor的比例是Eden:S0:S1=8:1:1，将Survivor分成了两个区域S0和S1来进行赋值，这种做法是为了弥补原始复制算法直接将一半空间作为空闲空间的浪费。IBM公司表示：Young区有98%的对象都是朝生夕死的，生命周期极短，所以说一次GC下来存活的对象很少，所以没必要用一半空间来复制。 标记-整理算法 ​ 标记-整理算法就是为了老年代而设计的算法，标记-整理算法和标记-清除算法的区别在最后一步，标记-整理不会直接对对象清理，而是进行移动，将存活对象移动到一端，然后清理掉边界以外的对象。 回收前： 回收后： 分代收集算法 ​ 目前主流的商业虚拟机都是采用分代收集算法，这种算法就是上面三种算法的结合。新生代采用复制算法，老年代采用标记-整理或标记-清除算法。 垃圾收集器 Serial 和Serial Old 收集器 Serial 单线程，GC时Stop The World（STW），暂停所有用户线程。 Serial Old 单线程，作用与老年代。标记整理算法 ​ 优点：单线程收集效率高 ​ 缺点：需要STW，暂停所有用户线程 ​ 算法： Serial采用复制算法 ；Serial Old采用标记-整理算法 ParNew收集器 ​ ParNew收集器是Serial收集器的多线程版本，实现并行收集， 原理跟Serial一致（并行指的是多个GC线程并行，但是用户线程还是暂停，并发指的是用户线程和GC线程同时执行）。ParNew默认开启和CPU个数相同的线程数进行回收。 ​ 优点：在多CPU时，比Serial的效率高。 ​ 缺点：还是需要STW，单CPU时比Serial效率低 ​ 算法：复制算法 Parallel Scavenge 收集器 新生代收集器，也是复制算法，和ParNew一样并行的多线程收集器，更关注系统的吞吐量[吞吐量=(运行用户代码的时间) / (运行用户代码的时间+ GC 时间) ]Parallel Scavenge 提供了两个参数用于精确控制吞吐量： 123456789-XX:MaxGCPauseMillis //GC最大停顿毫秒数，必须大于0-XX:GCTimeRation //设置吞吐量大小，大于0小于100，默认值为99-XX:+UseAdaptiveSizePolicy //开启自适应策略//你会不会觉得把MaxGCPauseMillis设置小点就会让GC速度变快？//答案是否定的，如果设置时间过小，Parallel Scavenge 会牺牲吞吐量和新生代空间来交换，//比如新生代400Mb需要GC时间为100ms，设置成50ms了，那么就会把新生代调小为200Mb，这样肯定时间就降下来了，//然而这种操作可能会降低吞吐量，原先10s触发一次GC，每次100ms，// 修改时间后变成5s触发一次GC，每次70ms，那么10ms触发两次GC的时间变成了140ms，吞吐量反而降低。 Parallel Old 收集器 是Parallel Scavenge 的老年代版本，使用标记-整理算法，因为Parallel Scavenge 无法和CMS搭配使用，所以只能和Serial Old。自从Parallel Old出现，就有了Parallel Scavenge +Parallel Old的组合，这是JDK8使用的，注重吞吐量的一组收集器。 CMS收集器 这是优化GC停顿时间为目标的收集器，并发回收（仍然需要STW，但是时间很短）。通过-XX:+UseMarkSweepGC启用。CMS基于标记-清除算法实现。整个过程分为四步： 初始标记：需要STW，标记GC Roots对象。 并发标记：这个阶段可以和用户线程一起进行，分为三步： 根据第一步找到的GC Roots开始搜索跟GC Roots相连的对象。 预清理：处理并发标记之后发生变化的对象。 可被终止的预清理：有一个abort 触发条件，该阶段存在的目的是希望能发生一次Young GC，来减少Young区对象数量，降低重新标记的工作量，因为重新标记会扫描整个堆内空间，可以通过参数-XX:+CMSScavangeBeforeRemark 控制在重新标记前发生一次Young GC，默认为false。 重新标记：需要STW，这个阶段是为了修正在阶段2标记之后产生变化的对象。 并发清除：和用户线程同时进行，开始正式清理垃圾，此阶段产生的垃圾留待下次清除。 优点：并发收集，低停顿 缺点：产生大量碎片，并发阶段会降低吞吐量 G1收集器 ​ G1是以优化GC停顿时间为目标的收集器，它尝试以高概率满足GC停顿时间为目标，同时实现高吞吐量。在G1中，将堆的整个内存布局做了修改，在G1中整个堆划分为多个大小相等的独立区域Region，虽然在逻辑上还保留了新生代和老年代，但是物理上已经隔离了，G1的堆内存布局如下图 ： 上图智能柜被划分成一组大小相同的Region，每个Region都是连续的虚拟内存范围，G1可以知道哪个Region区域内大部分是空的，这样就可以在每次允许的收集时间内优先回收价值最大的Region区域（根据回收所获得的空间大小以及回收需要的时间综合考虑）所以这就是G1叫做Garbage-First的原因。G1是JDK8默认的垃圾收集器。G1的工作流程和CMS很相似，区别在最后的步骤。也有四步： 初始标记：需要STW，标记下GC Roots关联的对象，并且修改TAMS（Next Top at Mark Start）的值，使得下一阶段并发运行时，能在正确可用的Region中创建对象。 并发标记：和CMS一样，主要是进行GC Roots的向下搜索，找出存活对象进行标记。 最终标记：需要STW，和CMS一样，这个阶段是修正并发标记期间因用户程序运行而导致变动的对象。 筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间制定回收计划。 G1的第一个重点是为运行需要大堆且GC延迟有限的应用程序的用户提供解决方案，这就意味着堆大小约为6G或更大，并且稳定且可预测的暂停时间低于0.5秒。如果应用程序具备以下特性，可以考虑切换到G1收集器： 超过50%的Java堆被实时数据占用 对象分配率或提升率差异很大 当前应用程序GC停顿时间超过0.5秒，又想缩短停顿时间 各收集对比 收集器 串行/并行/并发 新生代/老年代 算法 目标 适用场景 Serial 串行 新生代 复制 响应速度优先 单CPU环境下的Client模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单CPU环境下的Client模式，CMS的后备预案 ParNew 并行 新生代 复制 响应速度优先 多CPU环境时在Server模式下与CMS配合使用 Parallel Scavenge 并行 新生代 复制 吞吐量优先 在后台运算且不需要太多交互的任务 Parallel 并行 老年代 标记-整理 吞吐量优先 在后台运算且不需要太多交互的任务 CMS 并发 老年代 标记-清除 响应速度优先 集中在互联网网站 或 B/S系统服务端中的Java应用 G1 并发 兼顾 标记-整理+复制 响应速度优先 面向服务端应用 串行收集器：Serial和Serial Old单线程收集，适用于内存较小的嵌入式设备。 并行收集器【吞吐量优先】：Parallel Scavenge + Parallel Old，适用于科学计算、后台处理等场景。 并发收集器【GC停顿时间优先】：CMS和G1，适用于对时间有要求的场景，例如Web应用。 调优 所谓调优就是设置一个合理的JVM参数，适配当前系统运行。 参数 可以分成三类：标准参数，-X参数，-XX参数 标准参数 ​ 以&quot;-&quot;开头的参数称为标准参数，是任何一个JDK版本都支持的，比较稳定，不会随版本更新和改变。例如-version,-help,-server。 -X参数 ​ 以-X开头的参数是在特定版本HotSpot支持的命令。JDK版本变化之后，参数可能变化，这个参数用的较少。 -XX参数 -XX是不稳定的参数，也是主要参数，分为Boolean类型和非Boolean类型。 Boolean类型 -XX:[+-]&lt;name&gt;：+或-表示启用或者禁用name属性 123456表示启用CMS垃圾收集器-XX:+UseConcMarkSweepGC表示启用G1垃圾收集器-XX:+UseG1GC表示打印出所有的JVM参数信息-XX:+PrintFlagsFinal 非Boolean类型 -XX&lt;name&gt;=&lt;value&gt;：name表示属性，value表示属性对应的值 12设置最大永久代空间大小为5M-XX:MaxMetaspaceSize=5M 其他 123-Xms1000 等价于 -XX:InitialHeapSize=1000-Xmx1000 等价于 -XX:MaxHeapSize=1000-Xss1000 等价于 -XX:ThreadStackSize=1000 常用参数 设置 说明 -XX:ClCompilerCount=3 最大并行编译数，大于1时可以提高编译速度，但会影响系统稳定性 -XX:InitialHeapSize=100m 初始堆大小，可以简写为-Xms100 -XX:MaxHeapSize 最大堆大小，可以简写为-Xmx100 -XX:NewSize=20m 设置年轻代大小 -XX:MaxNewSize 设置年轻代最大值 -XX:OldSize=50m 设置老年代大小 -XX:MetaspaceSize=50m 设置方法区大小，JDK8才有，用元空间代替方法区 -XX:+UseParallelGC 设置Parallel Scavenge作为新生代收集器系统默认会选择Parallel Old作为老年代收集器 -XX:NewRatio 新生代和老年代的比值比如 -XX:NewRatio=4表示新生代：老年代=1：4 -XX:SurvivorRatio 表示Survivor区和Eden区的比值比如-XX:SurvivorRatio=8表示（S0或S1):Eden=1:8 命令监控工具 待续 参考： Java SE Specifications (oracle.com) JVM万字总结 - 掘金 (juejin.cn) 【JVM系列8】JVM知识点总览 - 掘金 (juejin.cn) JVM8内存模型_jdk8内存模型_余生之君的博客-CSDN博客 JVM内存模型总结，有各版本JDK对比、有元空间OOM监控案例、有Java版虚拟机，综合实践学习！ - 小傅哥 - 博客园 (cnblogs.com) https://zhuanlan.zhihu.com/p/297001119","categories":[{"name":"Java","slug":"Java","permalink":"https://solitaire-12.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://solitaire-12.github.io/tags/JVM/"}]},{"title":"内网穿透","slug":"Server/内网穿透","date":"2024-03-18T09:05:07.000Z","updated":"2024-03-19T06:41:52.244Z","comments":true,"path":"2024/03/18/Server/内网穿透/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"","text":"环境： 服务端阿里云： CentOS 8.5.2111 客户端：windows 11 / windows 10 frp 0.42 第一步 官网下载frp软件 笔者使用的版本：链接：https://pan.baidu.com/s/1cjmUiOY8iRIywx6whkhRdg 提取码：gatr 第二步 服务端： 将 frp_0.42.0_linux_amd64.tar.gz压缩包传给linux 进入到文件存放目录 123tar -zxvf frp_0.42.0_linux_amd64.tar.gzcd frp_0.42.0_linux_amd64/vi frps.ini 💬提醒：只要bind_port的7000端口没被占用，一般不建议修改。 12./frps -c frps.ini #临时启动nohup ./frps -c frps.ini &amp; #永久启动 客户端： 解压 frp_0.42.0_windows_amd64.zip ，注意关闭一下杀毒软件。 打开之后，修改frpc.ini文件。 💬解释： 12[ssh]定义一个使用 [type] 协议的url: [local_ip]:[local_port]被[server_addr]:[remote_port]代理了。即：用户访问 [server_addr]:[remote_port] 后，服务器&quot;跳转&quot;到 [local_ip]:[local_port] 启动 12# 进入cmdfrpc.exe -c frpc.ini ⚠️注意：假如你将frpc.ini中的remote_port和frps.ini中的dashboard_port配置成一样的话，启动客户端的时候，就会出现 [ssh] start error: port unavailable。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|项目部署","slug":"Server/项目上线","date":"2024-03-18T08:25:07.000Z","updated":"2024-03-18T09:02:45.468Z","comments":true,"path":"2024/03/18/Server/项目上线/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/","excerpt":"","text":"环境 系统：Centos 8.4.2105 docker : 24.0.5 nginx: nginx/1.25.1 后端 宿主机安装 后端达成jar包上传到服务器 ps -ef | grep java查看有没有在运行的java项目，要是端口冲突的话，直接kill java -jar没有问题之后，nohup java -jar x.jar &gt; x.log 2&gt;&amp;1 &amp; 就可以。 docker内部 创建Dockerfile vi Dockerfile 1234FROM openjdk:8ADD 18080.jar test.jarEXPOSE 18080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;test.jar&quot;] 描述： FROM openjdk:8:拉取基础镜像 ADD 18080.jar test.jar：将18080.jar复制到镜像中，重命名成test.jar EXPOSE 18080:声明端口，一般指定的是jar运行端口 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;test.jar&quot;]：容器启动之后执行的命令 MAINTAINER xx: 添加作者信息 构建镜像 1docker build -t test . 描述： test：镜像名称 .：表示Dockerfile在当前目录下 查看镜像 1docker images 运行进行 1docker run -d --restart=always --name test -p 8080:18080 test 描述： -d：表示后台运行容器 --restart=always：代表容器在停止或者服务器开机之后会自动重启 --name test:命名成test -p 8080:18080：端口映射 [宿主机端口]:[容器端口] test:运行的镜像 更新jar包 1docker cp new.jar [容器id]:/test.jar 随后，重启容器 Docker部署可执行jar包-阿里云开发者社区 (aliyun.com) 前端 项目打包 打包之后将项目放在挂载的html目录下,详情查看docker安装nginx | 线上跳转↗️ 挂载项目： 将项目挂载到文件夹a里边 配置nginx 修改前的配置文件： 修改后的配置文件： 注意事项 要是jar运行在宿主机(安装dokcer的服务器)上面的话，建议server_name修改成172.17.0.1(这个地址是安装docker之后，默认生成的网桥)。用ifconfig -a可以查看Linux 的IP地址 不要在 localtion / &#123;&#125;这块里边取写 proxy_pass，会网页都打不开。 倘若有第二个前端项目的话，同样html目录下面创建挂载文件夹并把文件存放在内。然后在写一个localtion块，修改一下listen端口。例如： 问题排查： 1.运行jar包服务器卡死 环境： 系统：8.5.2111 配置：2核2G 目标服务： Minio，frp，docker，nginx，redis，mysql，前端，后端 场景： 服务器运行着Minio，frp，nginx，docker，redis-docker，mysql-docker，前端。将后端jar包上传服务器，nohup java -jar xx &amp;连接服务器的xshell敲命令执行卡顿，无法重连xshell，随后服务器卡死。 问题排查： 观察到xshell命令还是能敲上的，但是键盘敲击之后，xshell界面很久才能回显，执行也要很久很久，而且重连xshell也是很长时间连接不上。 类似这种反应时间很长，系统出现&quot;死机&quot;的现象，多半是内存不足。 为啥会内存不足呢？ 重启服务器之后，重新配置好需要的环境，不运行jar包。查看top命令： 观察其中的进程，注意到有个mysqld占用了22.4%的存，整台服务器的内存是2G，实际运行起来指定没有2048M的，以及其他一些系统支持的，算亏损10%，空闲内存实际约为1850M。刨去mysqld默认占用的1G，实际占用的450M。要想维系整个系统的开支，可用内存也就1G左右。 将jar在开发环境上运行，观察到其占用了开发电脑1000-1300M的内存资源。 解决方案也就呼之欲出了： 配置java -jarJVM的参数，限定其内存大小。例如： 1java -Xmx512M -jar xxx.jar 从mysqld上解决，参考1 参考2 它是Performance Schema 的大小，默认配置是1G。 此时基本解决内存不足问题。 2.jar包运行，CPU飙升至190% 环境： 系统：8.5.2111 配置：2核2G 目标服务器任务进程： Minio，frp，docker，nginx，redis，mysql，前端，后端 场景： 服务器运行着Minio，frp，nginx，docker，redis-docker，mysql-docker，前端。将后端jar包上传服务器，nohup java -jar xx &amp;后，top指令监测到cpu处在190%附近。 问题排查： 通过 命令，查看该进程下的线程资源占用情况。 1ps -mp pid -o THREAD,tid,time 将其中%CPU高的线程TID进行转码 1print &quot;%x\\n&quot; TID 通过查看cpu占用很高的线程状态 1jstack PID | grep [0xTID:第二部转码出来的tid] 如果线程还处在Runnable状态，那么通过jstack去找到详情。如果问题指向代码，那就去修改。 到此基本解决。 当然，还有个情况就是，正常启动直接拉爆，随后又静默到1%的，查线程高占用的都停止了，这种情况下，倘若后期还有MQ什么的其他服务要用的话，建议将升级到4核cpu。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"部署","slug":"部署","permalink":"https://solitaire-12.github.io/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"linux|docker安装RabbitMQ","slug":"Server/docker安装RabbitMQ","date":"2024-03-18T08:23:07.000Z","updated":"2024-03-18T08:40:58.750Z","comments":true,"path":"2024/03/18/Server/docker安装RabbitMQ/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker%E5%AE%89%E8%A3%85RabbitMQ/","excerpt":"","text":"工欲善其事必先利其器：windows下载erlang 下载RabbitMQ 下载RabbitMQ源码 Docker安装RabbitMQ 12345678910111213# 查找rabbitmq镜像docker search rabbitmq# pull镜像docker pull rabbitmq# 运行mq ## -p [暴露的宿主机端口]:[docker内部端口]docker run -d --hostname rabbit-test --name rabbit \\-p 15672:15672 -p 5672:5672 rabbitmq# 进入mq镜像docker exec -it [容器id] /bin/bash# 运行rabbitmq-plugins enable rabbitmq_management# 默认账号密码：guest：guest","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|docker安装nginx","slug":"Server/docker安装nginx","date":"2024-03-18T08:23:07.000Z","updated":"2024-03-18T08:33:54.888Z","comments":true,"path":"2024/03/18/Server/docker安装nginx/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker%E5%AE%89%E8%A3%85nginx/","excerpt":"","text":"centos8.5.2111 拉取镜像 1docker pull nginx 创建Nginx挂载目录 123mkdir -p mytools/nginx/confmkdir -p mytools/nginx/logmkdir -p mytools/nginx/html 将容器中的配置复制到宿主机 12345678# 生成容器docker run --name nginx -p 9001:80 -d nginx# 将容器nginx.conf文件复制到宿主机docker cp nginx:/etc/nginx/nginx.conf /mytools/nginx/conf/nginx.conf# 将容器conf.d文件夹下内容复制到宿主机docker cp nginx:/etc/nginx/conf.d /mytools/nginx/conf/conf.d# 将容器中的html文件夹复制到宿主机docker cp nginx:/usr/share/nginx/html /mytools/nginx/ 正式启动nginx 12345678docker run \\-p 9002:80 \\--name nginx \\-v /mytools/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /mytools/nginx/conf/conf.d:/etc/nginx/conf.d \\-v /mytools/nginx/log:/var/log/nginx \\-v /mytools/nginx/html:/usr/share/nginx/html \\-d nginx:latest 查看运行状态 1curl localhost:9002 公网IP访问 修改html查看运行状态 查看是否生效 1docker restart nginx","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|docker安装redis","slug":"Server/docker安装redis","date":"2024-03-18T08:22:07.000Z","updated":"2024-03-18T08:31:58.663Z","comments":true,"path":"2024/03/18/Server/docker安装redis/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker%E5%AE%89%E8%A3%85redis/","excerpt":"","text":"centos 8.5.2111 拉取redis镜像 1docker pull redis 准备redis的配置文件 官网： redis 6.0.6 下载 – Redis中国用户组（CRUG） 把redis.conf上传到服务器redis安装的位置 配置redis.conf文件 bind 127.0.0.1 #注释掉这部分，使redis可以外部访问 daemonize no#用守护线程的方式启动 requirepass 你的密码#给redis设置密码 appendonly yes#redis持久化 默认是no tcp-keepalive 300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300 123456789101112#注释掉这部分，使redis可以外部访问bind 127.0.0.1 #用守护线程的方式启动daemonize no#给redis设置密码requirepass 你的密码#redis持久化 默认是noappendonly yes#防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300tcp-keepalive 300 # :/[findword] 在vi命令中寻找文字，最好加个空格去找 创建本地与docker映射目录 12mkdir mytools/redismkdir mytools/redis/data 把上述的redis.conf复制到redis目录下 启动 1sudo docker run -p 6379:6379 --name redis -v /mytools/redis/redis.conf:/etc/redis/redis.conf -v /mytools/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes -p 6379:6379:把容器内的6379端口映射到宿主机6379端口-v /data/redis/redis.conf:/etc/redis/redis.conf：把宿主机配置好的redis.conf放到容器内的这个位置中-v /data/redis/data:/data：把redis持久化的数据在宿主机内显示，做数据备份redis-server /etc/redis/redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动–appendonly yes：redis启动后数据持久化 查看日志：docker logs redis","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|docker安装minio","slug":"Server/minio","date":"2024-03-18T08:22:07.000Z","updated":"2024-03-18T09:10:40.271Z","comments":true,"path":"2024/03/18/Server/minio/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/minio/","excerpt":"","text":"环境 centos 8.5 创建minio文件夹 12mkdir /mytools/miniocd /mytools/minio wget下载minio 1wget https://dl.minio.io/server/minio/release/linux-amd64/minio 创建日志，授权 12touch minio.logchmod 777 minio 启动minio 12# 后面跟着的是静态文件挂载目录./minio server /opt/minio/data **问题原因：**笔者编写文档之前，运行过minio，这里显示端口占用问题，kill一下进程就好了 红字：警告:检测到默认凭据’minioadmin:minioadmin’，我们建议您使用’MINIO_ROOT_USER’和’MINIO_ROOT_PASSWORD’环境变量更改这些值 配置环境变量 12345vim /etc/profile export MINIO_ROOT_USER=fileadmin export MINIO_ROOT_PASSWORD=fileadminsource /etc/profile 指定端口重启minio 12# 有需求自己换成自己的存放目录./minio server /opt/minio/data --console-address &quot;:9050&quot; 设置后台启动 12345vim start.shnohup /mytools/minio/minio server /opt/minio/data --console-address &quot;:9050&quot; &gt; /opt/minio/minio.log 2&gt;&amp;1 &amp;sh start.sh 问题： minio服务部署在云端时，配置服务网站要用公网ip，不然没办法回显","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|docker安装mysql8","slug":"Server/docker安装mysql8","date":"2024-03-18T08:21:07.000Z","updated":"2024-03-18T08:29:42.068Z","comments":true,"path":"2024/03/18/Server/docker安装mysql8/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker%E5%AE%89%E8%A3%85mysql8/","excerpt":"","text":"拉取镜像 1docker pull mysql:8.0.23 检查镜像 1docker images 启动镜像 1234567891011sudo docker run -p 3306:3306 --name mysql \\-v /usr/local/docker/mysql/mysql-files:/var/lib/mysql-files \\-v /usr/local/docker/mysql/conf:/etc/mysql \\-v /usr/local/docker/mysql/logs:/var/log/mysql \\-v /usr/local/docker/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:8.0.23docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql 1docker logs -f mysql #查看启动日志 进入容器 1docker exec -it mysql bash 方法二 下载mysql 1docker pull mysql:8.0.23 创建文件夹做挂载 12345//创建文件夹做挂载mkdir -p /mydata/mysql/confmkdir /mydata/mysql/data//创建my.cnf配置文件vi /mydata/mysql/conf/my.cnf my.cnf添加如下内容 123456789101112131415[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_passwordsecure_file_priv=/var/lib/mysqlexpire_logs_days=7sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTIONmax_connections=1000lower_case_table_names=1 [client]default-character-set=utf8 [mysql]default-character-set=utf8 注意： 你的数据库要是从本地windows上迁移到linux的话，lower_case_table_names=1,这个一定要加上，不然的话要重新部署，很麻烦 创建容器 12345678910docker run \\--restart=always \\--privileged=true \\-p 3306:3306 --name mysql \\-v /mydata/mysql/log:/var/log/mysql \\-v /mydata/mysql/data:/var/lib/mysql \\-v /mydata/mysql/conf/my.cnf:/etc/mysql/my.cnf \\-v /mydata/mysql/conf/conf.d:/etc/mysql/conf.d \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:8.0 进入容器 1docker exec -it mysql bash 进入mysql 123mysql -u root -p# 查看数据库show databases","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|安装Git/Maven","slug":"Server/GitMaven","date":"2024-03-18T08:20:07.000Z","updated":"2024-03-18T08:23:14.809Z","comments":true,"path":"2024/03/18/Server/GitMaven/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/GitMaven/","excerpt":"","text":"安装Git 1yum install -y git 校验安装结果 1git --version 安装maven 创建存放maven的文件夹 1mkdir -p /mytools/maven 将maven.gz上传到该文件夹 解压 1tar -xvf apache-maven-3.9.4-bin.tar.gz 配置环境变量 1234vim /etc/profile export MAVEN_HOME=/mydata/maven/apache-maven-3.9.4 export PATH=$&#123;MAVEN_HOME&#125;/bin:$PATHsource /etc/profile 验证 1mvn -v 配置阿里镜像(看情况)","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|安装Docker","slug":"Server/docker","date":"2024-03-18T08:20:07.000Z","updated":"2024-03-18T08:26:17.374Z","comments":true,"path":"2024/03/18/Server/docker/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/docker/","excerpt":"","text":"环境 ： centos 8.4.2105 检查是否存在docker 1docker -v 卸载docker 12345678910yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 123yum remove docker-ce \\ docker-ce-cli \\ containerd 设置仓库 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 稳定仓库 12# 阿里云sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 1234# 清华镜像sudo yum-config-manager \\ --add-repo \\ https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 安装 Docker Engine-Community 1sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 问题： 原因：CentOS-8于2021年12月31日停止了源的服务 解决步骤： 1234567# 1cd /etc/yum.repos.d# 2mkdir bakcp * bak/# 3vi root_.repo #把enabled=1，改成enable=0 指定版本安装 123456789$ yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io 启动docker 123sudo systemctl start docker# 运行hello-world镜像，查看是否安装成功sudo docker run hello-world 卸载docker 1234# 删除安装包yum remove docker-ce# 删除镜像、容器、配置文件等内容rm -rf /var/lib/docker centos 8.2安装问题 设置仓库时发生问题： 解决：更新一下yum 1yum -y update 出现Failed to download metadata for repo ‘appstream’: Cannot prepare internal mirrorlist: No URLs in mirrorlist 问题原因： 因为centos8项目官方已于2021年底停止维护，相关源已无法使用，所以网上22年前的换源教程都已无法使用。 解决： 12345678#进入配置文件目录cd /etc/yum.repos.d/#删除旧的配置文件rm -rf *.repo# 下载可用的.repo文件wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo# 运行 yum makecache 生成缓存yum makecache","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"linux|安装JDK","slug":"Server/JDK","date":"2024-03-18T08:14:07.000Z","updated":"2024-03-18T08:23:34.967Z","comments":true,"path":"2024/03/18/Server/JDK/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/JDK/","excerpt":"","text":"清华云下载jdk ： https://repo.huaweicloud.com/java/ 12345678910111213141516171819202122# 查看是否安装过jdkrpm -qa | grep java# ↑这里要是存在内容，执行删除rpm -qa | grep java | xargs rpm -e --nodeps# 查看java版本java -version# 创建存放java的文件mkdir /usr/java# cd进入这一个文件夹# 把下载好的jdk上传到这个文件夹下# 解压tar -xvf jdk1.8.0_202ar.gz# 配置环境vi /etc/profile# 在文件末尾添加 【注意=附近不要有空格】export JAVA_HOME=/usr/java/jdk1.8.0_202export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib/ export PATH=$PATH:$JAVA_HOME/bin# 初始化配置 - 执行这条语句，可以让环境立即生效，不需要重启source /etc/profile# 查看版本 (有信息的话，就安装成功了)java -version 如果上述中没有添加到环境中，尝试终端直接运行以下代码 1234export JAVA_HOME=/mytools/java/jdk1.8.0_202export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"Hexo|图片相关","slug":"Hexo/Hexo-图片相关","date":"2024-03-18T07:14:55.000Z","updated":"2024-03-18T07:55:33.857Z","comments":true,"path":"2024/03/18/Hexo/Hexo-图片相关/","permalink":"https://solitaire-12.github.io/2024/03/18/Hexo/Hexo-%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3/","excerpt":"","text":"1.相对路径挂载图片【文章显示】 在 _config.yml文件中配置 post_asset_folder 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 💬配置之后，当执行 hexo new titleName之后，会在该titleName.md文件夹的同级目录下生成一个同名文件夹用来存放图片资源。 .md文件中使用 1![](photoName.jpg) 💬hexo-renderer-marked默认渲染引擎，通过hexo g之后，会将该图片路径渲染成绝对路径。在文章列表中，无法加载图片。 2.绝对路径挂载图片【主页显示】 在source文件夹下，创建一个img文件夹用来存放图片 .md文件中使用 1![](/img/photoName.jpg) 💬/img代表根目录下的img文件夹，其中 /指代根目录【public文件夹】 3.同时显示 安装 hexo-asset-image 1npm hexo-asset-image --save 安装之后，发现图片路径都不显示了，F12查看图片路径变成了/.io//xxx.xx。 修复上述bug。进入到node_modules找到hexo-asset-image插件，用下述代码替换掉index.js原有代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&quot;use strict&quot;;var cheerio = require(&quot;cheerio&quot;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&quot;.&quot;);hexo.extend.filter.register(&quot;after_post_render&quot;, function (data) &#123; var config = hexo.config; if (config.post_asset_folder) &#123; var link = data.permalink; if (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &quot;/&quot;, 1) + 1; else var beginPos = getPosition(link, &quot;/&quot;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&quot;/&quot;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&quot;excerpt&quot;, &quot;more&quot;, &quot;content&quot;]; for (var i = 0; i &lt; toprocess.length; i++) &#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false, &#125;); $(&quot;img&quot;).each(function () &#123; if ($(this).attr(&quot;src&quot;)) &#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&quot;src&quot;).replace(&quot;\\\\&quot;, &quot;/&quot;); if (!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&quot;/&quot;).filter(function (elem) &#123; return elem != &quot;&quot;; &#125;); var srcArray = src.split(&quot;/&quot;).filter(function (elem) &#123; return elem != &quot;&quot; &amp;&amp; elem != &quot;.&quot;; &#125;); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&quot;/&quot;); $(this).attr(&quot;src&quot;, config.root + link + src); console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + config.root + link + src); &#125; &#125; else &#123; console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;); console.info &amp;&amp; console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 替换之后，重新hexo g即可。 4.支持emoji hexo-renderer-marked默认渲染引擎并不支持emoji，却换到可以支持的渲染引擎。笔者使用的是 hexo-renderer-markdown-it。 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save 在 _config.yml文件中配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243# hexo-renderer-markdown-itmarkdown: preset: &quot;default&quot; render: html: true xhtmlOut: false langPrefix: &quot;language-&quot; breaks: true linkify: true typographer: true quotes: &quot;“”‘’&quot; enable_rules: disable_rules: plugins: - markdown-it-abbr - markdown-it-cjk-breaks - markdown-it-deflist - markdown-it-emoji - markdown-it-footnote - markdown-it-ins - markdown-it-mark - markdown-it-sub - markdown-it-sup # - markdown-it-checkbox # - markdown-it-imsize # - markdown-it-expandable - name: markdown-it-container options: success - name: markdown-it-container options: tips - name: markdown-it-container options: warning - name: markdown-it-container options: danger anchors: level: 2 collisionSuffix: &quot;&quot; permalink: false permalinkClass: &quot;header-anchor&quot; permalinkSide: &quot;left&quot; permalinkSymbol: &quot;¶&quot; case: 0 separator: &quot;-&quot; 参考： Hexo图片相关 - 文章显示、主页显示、修改fancybox_hexo 文章缩略-CSDN博客 【Hexo】选择更高级的Markdown渲染器_hexo-renderer-marked-CSDN博客","categories":[{"name":"博客","slug":"博客","permalink":"https://solitaire-12.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://solitaire-12.github.io/tags/Hexo/"}]},{"title":"数据管理DMS","slug":"Server/dms","date":"2024-03-18T05:40:07.000Z","updated":"2024-03-18T09:12:06.386Z","comments":true,"path":"2024/03/18/Server/dms/","permalink":"https://solitaire-12.github.io/2024/03/18/Server/dms/","excerpt":"","text":"下载：数据管理DMS–下载中心 (aliyun.com) 本地部署： 安装好之后，登录实例即可。 问题：内网IP链接失败 解决方法：【本地数据库是MySQL】 登录数据库，切换到mysql 1select user,host from user; # 查看信息 ⚠️上述信息是指该用户名只能通过localhost这个地址进行访问。 修改root用户的host 1update user set host =&quot;%&quot; where user = &quot;root&quot;; 刷新权限 1flush privileges;","categories":[{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-03-14T05:00:15.235Z","updated":"2024-03-18T07:17:22.799Z","comments":true,"path":"2024/03/14/hello-world/","permalink":"https://solitaire-12.github.io/2024/03/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"初始","slug":"初始","permalink":"https://solitaire-12.github.io/categories/%E5%88%9D%E5%A7%8B/"}],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://solitaire-12.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://solitaire-12.github.io/categories/Java/"},{"name":"服务器","slug":"服务器","permalink":"https://solitaire-12.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"博客","slug":"博客","permalink":"https://solitaire-12.github.io/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"初始","slug":"初始","permalink":"https://solitaire-12.github.io/categories/%E5%88%9D%E5%A7%8B/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://solitaire-12.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"Java8","slug":"Java8","permalink":"https://solitaire-12.github.io/tags/Java8/"},{"name":"JVM","slug":"JVM","permalink":"https://solitaire-12.github.io/tags/JVM/"},{"name":"安装","slug":"安装","permalink":"https://solitaire-12.github.io/tags/%E5%AE%89%E8%A3%85/"},{"name":"部署","slug":"部署","permalink":"https://solitaire-12.github.io/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://solitaire-12.github.io/tags/Hexo/"}]}